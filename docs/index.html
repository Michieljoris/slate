
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Aum docs</title>

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .cd {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .nl {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <link href="stylesheets/screen-576aba22.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print-bccf8c07.css" rel="stylesheet" media="print" />
      <script src="javascripts/all-c5541673.js"></script>
  </head>

  <body class="index" data-languages="[]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar-cad8cdcb.png" alt="Navbar" />
      </span>
    </a>
    <div class="toc-wrapper">
        <div class="logo" style="min-height:30px;color:white;font-size:30px;padding:10px 0 0px 50px">Aum</div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <ul id="toc" class="toc-list-h1">
          <li>
            <a href="#table-of-contents" class="toc-h1 toc-link" data-title="Table of Contents">Table of Contents</a>
          </li>
          <li>
            <a href="#intro" class="toc-h1 toc-link" data-title="Intro">Intro</a>
          </li>
          <li>
            <a href="#getting-started" class="toc-h1 toc-link" data-title="Getting started">Getting started</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#useful-docs-to-read-first" class="toc-h2 toc-link" data-title="Useful docs to read first">Useful docs to read first</a>
                  </li>
                  <li>
                    <a href="#install" class="toc-h2 toc-link" data-title="Install">Install</a>
                  </li>
                  <li>
                    <a href="#starter-app" class="toc-h2 toc-link" data-title="Starter app">Starter app</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#core-concepts" class="toc-h1 toc-link" data-title="Core concepts">Core concepts</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#it-rsquo-s-om-next" class="toc-h2 toc-link" data-title="It’s om-next.">It’s om-next.</a>
                  </li>
                  <li>
                    <a href="#it-rsquo-s-a-loop" class="toc-h2 toc-link" data-title="It’s a loop">It’s a loop</a>
                  </li>
                  <li>
                    <a href="#it-rsquo-s-just-a-sql-query" class="toc-h2 toc-link" data-title="It’s just a sql query">It’s just a sql query</a>
                  </li>
                  <li>
                    <a href="#it-rsquo-s-just-websockets" class="toc-h2 toc-link" data-title="It’s just websockets">It’s just websockets</a>
                  </li>
                  <li>
                    <a href="#we-pretend-we-have-all-data-already-in-the-frontend" class="toc-h2 toc-link" data-title="We pretend we have all data already in the frontend">We pretend we have all data already in the frontend</a>
                  </li>
                  <li>
                    <a href="#om-next-mutations-almost" class="toc-h2 toc-link" data-title="Om-next mutations, almost">Om-next mutations, almost</a>
                  </li>
                  <li>
                    <a href="#integrant-for-state-managment" class="toc-h2 toc-link" data-title="Integrant for state managment">Integrant for state managment</a>
                  </li>
                  <li>
                    <a href="#not-boot-not-lein-but-tools-deps" class="toc-h2 toc-link" data-title="Not boot, not lein but tools.deps">Not boot, not lein but tools.deps</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#build-system" class="toc-h1 toc-link" data-title="Build system">Build system</a>
          </li>
          <li>
            <a href="#app-starting-process" class="toc-h1 toc-link" data-title="App starting process">App starting process</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#dev" class="toc-h2 toc-link" data-title="dev">dev</a>
                  </li>
                  <li>
                    <a href="#prod" class="toc-h2 toc-link" data-title="prod">prod</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#environment" class="toc-h1 toc-link" data-title="Environment">Environment</a>
          </li>
          <li>
            <a href="#config" class="toc-h1 toc-link" data-title="Config">Config</a>
          </li>
          <li>
            <a href="#websockets" class="toc-h1 toc-link" data-title="Websockets">Websockets</a>
          </li>
          <li>
            <a href="#database" class="toc-h1 toc-link" data-title="Database">Database</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#validation" class="toc-h2 toc-link" data-title="Validation">Validation</a>
                  </li>
                  <li>
                    <a href="#processing-parameters-and-results" class="toc-h2 toc-link" data-title="Processing parameters and results">Processing parameters and results</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#frontend-matters" class="toc-h1 toc-link" data-title="Frontend matters">Frontend matters</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#generic-recursive-read-with-hooks" class="toc-h2 toc-link" data-title="Generic recursive read with hooks">Generic recursive read with hooks</a>
                  </li>
                  <li>
                    <a href="#client-only-keys" class="toc-h2 toc-link" data-title="Client only keys">Client only keys</a>
                  </li>
                  <li>
                    <a href="#make-cmp-and-om-data" class="toc-h2 toc-link" data-title="make-cmp and om-data">make-cmp and om-data</a>
                  </li>
                  <li>
                    <a href="#garbage-collection" class="toc-h2 toc-link" data-title="Garbage collection">Garbage collection</a>
                  </li>
                  <li>
                    <a href="#internationalization" class="toc-h2 toc-link" data-title="Internationalization">Internationalization</a>
                  </li>
                  <li>
                    <a href="#pre-merge-hooks" class="toc-h2 toc-link" data-title="Pre-merge hooks">Pre-merge hooks</a>
                  </li>
                  <li>
                    <a href="#merging-pushed-data" class="toc-h2 toc-link" data-title="Merging pushed data">Merging pushed data</a>
                  </li>
                  <li>
                    <a href="#generic-undo-redo-revert" class="toc-h2 toc-link" data-title="Generic undo/redo/revert.">Generic undo/redo/revert.</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#backend-parser" class="toc-h1 toc-link" data-title="Backend parser">Backend parser</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#table-aliases" class="toc-h2 toc-link" data-title="Table aliases">Table aliases</a>
                  </li>
                  <li>
                    <a href="#virtual-tables" class="toc-h2 toc-link" data-title="Virtual tables">Virtual tables</a>
                  </li>
                  <li>
                    <a href="#have-backend-return-calculated-data" class="toc-h2 toc-link" data-title="Have backend return calculated data">Have backend return calculated data</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#testing" class="toc-h1 toc-link" data-title="Testing">Testing</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#backend-testing" class="toc-h2 toc-link" data-title="Backend testing">Backend testing</a>
                  </li>
                  <li>
                    <a href="#frontend-testing" class="toc-h2 toc-link" data-title="Frontend testing">Frontend testing</a>
                  </li>
                  <li>
                    <a href="#run-backend-in-frontend-for-testing-for-example" class="toc-h2 toc-link" data-title="Run backend in frontend (for testing for example)">Run backend in frontend (for testing for example)</a>
                  </li>
                  <li>
                    <a href="#whole-stack-testing" class="toc-h2 toc-link" data-title="Whole stack testing">Whole stack testing</a>
                  </li>
                  <li>
                    <a href="#fixtures-per-test" class="toc-h2 toc-link" data-title="Fixtures per test">Fixtures per test</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#debugging" class="toc-h1 toc-link" data-title="Debugging">Debugging</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#dev-cards" class="toc-h2 toc-link" data-title="Dev-cards">Dev-cards</a>
                  </li>
                  <li>
                    <a href="#frontend-om-inspector" class="toc-h2 toc-link" data-title="Frontend om inspector">Frontend om inspector</a>
                  </li>
                  <li>
                    <a href="#it-rsquo-s-possible-to-set-some-flags-in-local-storage-to-get-some-output-in-console-etc" class="toc-h2 toc-link" data-title="It’s possible to set some flags in local storage to get some output in console etc:">It’s possible to set some flags in local storage to get some output in console etc:</a>
                  </li>
                  <li>
                    <a href="#in-boot-scripts-there-rsquo-s-tail-boot-to-inspect-logstash-output" class="toc-h2 toc-link" data-title="In boot-scripts there’s tail.boot to inspect logstash output:">In boot-scripts there’s tail.boot to inspect logstash output:</a>
                  </li>
                  <li>
                    <a href="#trying-queries" class="toc-h2 toc-link" data-title="Trying queries">Trying queries</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#how-to" class="toc-h1 toc-link" data-title="How to">How to</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#add-npm-modules" class="toc-h2 toc-link" data-title="Add npm modules">Add npm modules</a>
                  </li>
                  <li>
                    <a href="#querying-other-sources-than-a-mysql-database" class="toc-h2 toc-link" data-title="Querying other sources than a mysql database">Querying other sources than a mysql database</a>
                  </li>
                  <li>
                    <a href="#optimize-frontend" class="toc-h2 toc-link" data-title="Optimize frontend">Optimize frontend</a>
                  </li>
                  <li>
                    <a href="#start-app-with-different-ports-and-db" class="toc-h2 toc-link" data-title="Start app with different ports and db:">Start app with different ports and db:</a>
                  </li>
                  <li>
                    <a href="#throw-catch-exceptions" class="toc-h2 toc-link" data-title="throw catch exceptions">throw catch exceptions</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#good-to-know" class="toc-h1 toc-link" data-title="Good to know">Good to know</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#function-and-method-signatures" class="toc-h2 toc-link" data-title="Function and method signatures">Function and method signatures</a>
                  </li>
                  <li>
                    <a href="#syncing-of-front-and-backend" class="toc-h2 toc-link" data-title="Syncing of front and backend">Syncing of front and backend</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#modules-wip-code-exists-but-needs-to-be-added" class="toc-h1 toc-link" data-title="Modules (wip, code exists but needs to be added)">Modules (wip, code exists but needs to be added)</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#database-migration" class="toc-h2 toc-link" data-title="Database migration">Database migration</a>
                  </li>
                  <li>
                    <a href="#files-download" class="toc-h2 toc-link" data-title="Files download">Files download</a>
                  </li>
                  <li>
                    <a href="#pdfkit" class="toc-h2 toc-link" data-title="Pdfkit">Pdfkit</a>
                  </li>
                  <li>
                    <a href="#icons" class="toc-h2 toc-link" data-title="Icons">Icons</a>
                  </li>
                  <li>
                    <a href="#auth" class="toc-h2 toc-link" data-title="Auth">Auth</a>
                  </li>
                  <li>
                    <a href="#events" class="toc-h2 toc-link" data-title="Events">Events</a>
                  </li>
                  <li>
                    <a href="#af8207aece" class="toc-h2 toc-link" data-title="----">----</a>
                  </li>
                  <li>
                    <a href="#generic-save-records" class="toc-h2 toc-link" data-title="Generic save records">Generic save records</a>
                  </li>
                  <li>
                    <a href="#frontend-validation-of-form-values" class="toc-h2 toc-link" data-title="Frontend validation of form values">Frontend validation of form values</a>
                  </li>
                  <li>
                    <a href="#frontend-paging" class="toc-h2 toc-link" data-title="Frontend paging">Frontend paging</a>
                  </li>
                  <li>
                    <a href="#frontend-routing-and-url-state" class="toc-h2 toc-link" data-title="Frontend routing and url state">Frontend routing and url state</a>
                  </li>
                  <li>
                    <a href="#internationalization-2" class="toc-h2 toc-link" data-title="Internationalization">Internationalization</a>
                  </li>
                  <li>
                    <a href="#integrations" class="toc-h2 toc-link" data-title="Integrations">Integrations</a>
                  </li>
                  <li>
                    <a href="#files-upload" class="toc-h2 toc-link" data-title="Files upload">Files upload</a>
                  </li>
                  <li>
                    <a href="#frontend-testrunner" class="toc-h2 toc-link" data-title="Frontend testrunner">Frontend testrunner</a>
                  </li>
                  <li>
                    <a href="#frontend-data-inspector" class="toc-h2 toc-link" data-title="Frontend data inspector">Frontend data inspector</a>
                  </li>
                  <li>
                    <a href="#fullstack-mock-and-testing" class="toc-h2 toc-link" data-title="Fullstack mock and testing">Fullstack mock and testing</a>
                  </li>
                  <li>
                    <a href="#frontend-page-macro" class="toc-h2 toc-link" data-title="Frontend page macro">Frontend page macro</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#code-outline" class="toc-h1 toc-link" data-title="Code outline">Code outline</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#backend-3" class="toc-h2 toc-link" data-title="Backend">Backend</a>
                  </li>
                  <li>
                    <a href="#frontend-3" class="toc-h2 toc-link" data-title="Frontend">Frontend</a>
                  </li>
              </ul>
          </li>
      </ul>
        <ul class="toc-footer">
            <li><a href='https://www.github.com/Michieljoris/aum'>Aum on github</a></li>
            <li><a href='https://github.com/lord/slate'>Documentation Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id='table-of-contents'>Table of Contents</h1>
<ol>
<li> <a href="#orgb49d14b">Intro</a></li>
<li> <a href="#org65709bc">Getting started</a>

<ol>
<li> <a href="#orgcd7f32c">Useful docs to read first</a>

<ol>
<li> <a href="#org767bca6">React</a></li>
<li> <a href="#org3d88ebc">Om-next</a></li>
<li> <a href="#org1c1dbe8">Fulcro handbook</a></li>
<li> <a href="#orgd23da8b">See om-next docs for more useful links</a></li>
</ol></li>
<li> <a href="#orgef63e8b">Install</a></li>
<li> <a href="#orged97ec0">Starter app</a>

<ol>
<li> <a href="#org9756480">Install</a></li>
<li> <a href="#org1339c36">Run in development mode</a></li>
<li> <a href="#org35eb161">Run in production mode</a></li>
</ol></li>
</ol></li>
<li> <a href="#org3c83c05">Core concepts</a>

<ol>
<li> <a href="#org953459f">It&rsquo;s om-next.</a></li>
<li> <a href="#org55c1daa">It&rsquo;s a loop</a></li>
<li> <a href="#org028a648">It&rsquo;s just a sql query</a></li>
<li> <a href="#orga571920">It&rsquo;s just websockets</a></li>
<li> <a href="#orgc4208aa">We pretend we have all data already in the frontend</a></li>
<li> <a href="#orgba7807a">Om-next mutations, almost</a></li>
<li> <a href="#orge8ea368">Integrant for state managment</a></li>
<li> <a href="#orge122903">Not boot, not lein but tools.deps</a></li>
</ol></li>
<li> <a href="#org1c104bc">Build system</a></li>
<li> <a href="#orgf503e02">App starting process</a>

<ol>
<li> <a href="#orgb52f455">dev</a>

<ol>
<li> <a href="#orgf5a9abe">Backend</a></li>
<li> <a href="#orgbe39325">Frontend</a></li>
</ol></li>
<li> <a href="#orga8ab1e8">prod</a>

<ol>
<li> <a href="#org351d286">Backend</a></li>
<li> <a href="#orge5d2298">Frontend</a></li>
</ol></li>
</ol></li>
<li> <a href="#orgfef1aaa">Environment</a></li>
<li> <a href="#orgbf557fb">Config</a></li>
<li> <a href="#orgc2a531a">Websockets</a></li>
<li> <a href="#org561ccef">Database</a>

<ol>
<li> <a href="#org709a4a9">Validation</a></li>
<li> <a href="#org4af4e3d">Processing parameters and results</a></li>
</ol></li>
<li><a href="#org4130808">Frontend matters</a>

<ol>
<li> <a href="#orgd4ec91d">Generic recursive read with hooks</a>

<ol>
<li> <a href="#orged9999f">Intro</a></li>
<li> <a href="#org6f567e2">Adding hooks for keys and joins in the root query for returning values and building remote query</a></li>
</ol></li>
<li> <a href="#org8744aaf">Client only keys</a></li>
<li> <a href="#org6b58eae">make-cmp and om-data</a></li>
<li> <a href="#orgb5d4105">Garbage collection</a></li>
<li> <a href="#orgcb308dd">Internationalization</a></li>
<li> <a href="#org1b1bfc6">Pre-merge hooks</a></li>
<li> <a href="#org233ea68">Merging pushed data</a></li>
<li> <a href="#org5d63707">Generic undo/redo/revert.</a></li>
</ol></li>
<li><a href="#orgc68169c">Backend parser</a>

<ol>
<li> <a href="#org0a88b69">Table aliases</a></li>
<li> <a href="#org39403a9">Virtual tables</a></li>
<li> <a href="#org0b6510b">Have backend return calculated data</a>

<ol>
<li> <a href="#orgd6e7f9e">Calculate something over a (sub)query</a></li>
<li> <a href="#orge8de2b7">Define a read key in the backend</a></li>
<li> <a href="#orgec2b587">Redirect a read to a custom-read</a></li>
</ol></li>
</ol></li>
<li><a href="#orgda4213e">Testing</a>

<ol>
<li> <a href="#org8369083">Backend testing</a></li>
<li> <a href="#orge34eb43">Frontend testing</a>

<ol>
<li> <a href="#org50abb89">Install</a></li>
<li> <a href="#org47157fc">Test runner</a></li>
<li> <a href="#orgbf2e5fb">Snapshots</a></li>
</ol></li>
<li> <a href="#org34b0864">Run backend in frontend (for testing for example)</a></li>
<li> <a href="#orgd901d70">Whole stack testing</a></li>
<li> <a href="#org9e8843f">Fixtures per test</a></li>
</ol></li>
<li><a href="#orgebb6995">Debugging</a>

<ol>
<li> <a href="#org07f3f03">Dev-cards</a></li>
<li> <a href="#org9513e26">Frontend om inspector</a></li>
<li> <a href="#orge9f0987">It&rsquo;s possible to set some flags in local storage to get some output in console etc:</a></li>
<li> <a href="#org81f297e">In boot-scripts there&rsquo;s tail.boot to inspect logstash output:</a></li>
<li> <a href="#org24eb277">Trying queries</a></li>
</ol></li>
<li><a href="#orgd0f99c0">How to</a>

<ol>
<li> <a href="#org17fa8d7">Add npm modules</a></li>
<li> <a href="#org0ffbfb1">Querying other sources than a mysql database</a>

<ol>
<li> <a href="#org8ad8d59">Using more than one remote in the frontend</a></li>
<li> <a href="#orgcafbc91">Returning data fetched from another source asynchronously</a></li>
</ol></li>
<li> <a href="#org9161b68">Optimize frontend</a>

<ol>
<li> <a href="#orga792069">pathopt</a></li>
</ol></li>
<li> <a href="#org39f2993">Start app with different ports and db:</a></li>
<li> <a href="#orgf52ebd9">throw catch exceptions</a></li>
</ol></li>
<li><a href="#orge807e2c">Good to know</a>

<ol>
<li> <a href="#orgc19a199">Function and method signatures</a>

<ol>
<li> <a href="#orgbb0c359">read and mutate: [env key params] TODO-doc: update for aum</a></li>
</ol></li>
<li> <a href="#org7745bc6">Syncing of front and backend</a></li>
</ol></li>
<li><a href="#orgcf5490a">Modules (wip, code exists but needs to be added)</a>

<ol>
<li> <a href="#orge3357f7">Database migration</a></li>
<li> <a href="#org0cd69f1">Files download</a></li>
<li> <a href="#org94b5d25">Pdfkit</a></li>
<li> <a href="#org928962c">Icons</a></li>
<li> <a href="#org6d355eb">Auth</a>

<ol>
<li> <a href="#org0a408be">login/logout</a></li>
<li> <a href="#org9a4b233">subscriptions</a></li>
<li> <a href="#org508abfe">WIP accounts, users and roles</a></li>
<li> <a href="#org16c2970">Process-user and calc-role snippets</a></li>
</ol></li>
<li> <a href="#orga3cc35a">Events</a></li>
<li> <a href="#orgcd094d6">----</a></li>
<li> <a href="#orgf0d4a58">Generic save records</a></li>
<li> <a href="#org13c0a41">Frontend validation of form values</a></li>
<li><a href="#org5958414">Frontend paging</a></li>
<li><a href="#orgb7d310b">Frontend routing and url state</a></li>
<li><a href="#orgf0120a8">Internationalization</a>

<ol>
<li> <a href="#orgfd632c3">There is a common.i18n.cljc namespace which provides the translate fn which</a></li>
<li> <a href="#org342a1b2">use params in translation keys, so interpolation</a></li>
<li> <a href="#orgab73bda">load translations zipped!!!???!!!!</a></li>
</ol></li>
<li><a href="#org7f94a0b">Integrations</a>

<ol>
<li> <a href="#org6636654">Bugsnag, logging, newrelic etc</a></li>
<li> <a href="#orgb6070af">bugsnag</a></li>
</ol></li>
<li><a href="#org4589a23">Files upload</a></li>
<li><a href="#org4aafd43">Frontend testrunner</a></li>
<li><a href="#org2b27cf5">Frontend data inspector</a></li>
<li><a href="#org3414ab6">Fullstack mock and testing</a></li>
<li><a href="#org5fdc7d2">Frontend page macro</a></li>
</ol></li>
<li><a href="#orgc0fab13">Code outline</a>

<ol>
<li> <a href="#org57d9355">Backend</a></li>
<li> <a href="#orga50817a">Frontend</a>

<ol>
<li> <a href="#org7355ac9">app.core.cljs</a></li>
<li> <a href="#orga6997cf">Basic structure of an admin page.</a></li>
<li> <a href="#org3fbfc9b">Misc notes on code</a></li>
</ol></li>
</ol></li>
</ol>

<p><a id="orgb49d14b"></a></p>
<h1 id='intro'>Intro</h1>
<p>Aum is a somewhat opiniated library built on top of om next meant to be used
to build full stack apps in clojure/script. The backend implements a generic
resolver of om next queries against a sql database. The frontend lets you
build components with localized queries for data. The underlying frontend
part of the aum library then works out what needs to be requested from the
backend and what is already available. Many of the practical considerations
when it comes to building a actual production app have been incorporated
into the library such as security, database management, networking,
environment management, build system, internationalization, state management
etc. There is also a data inspector, test runner and fullstack testing
(emulating backend in frontend).</p>

<p>It&rsquo;s actually been used to build a fullstack production app at the last
business I worked at, and aum is extracted more or less from that app.
However it still can use a lot of work and documentation.</p>

<p><a id="org65709bc"></a></p>
<h1 id='getting-started'>Getting started</h1>
<p><a id="orgcd7f32c"></a></p>
<h2 id='useful-docs-to-read-first'>Useful docs to read first</h2>
<p><a id="org767bca6"></a></p>
<h3 id='react'>React</h3>
<p><a href="https://reactjs.org/docs/getting-started.html">https://reactjs.org/docs/getting-started.html</a></p>

<p>Om-next is built on react. Om-next components are basically classical react
components with a layer over them so om-next can do it&rsquo;s own optimisations and
control the render cycle. But just like in react you have access to the various
lifecycle hooks (but leave shouldComponentUpdate alone, this is managed by
om-next). You pass in props to subcomponents and components can have their own
local state. Basically om-next generates a tree of data from the app-state by
applying the root query of the app over it every time a transact is done or a
merge of data with app-state (in the reconciler for instance when data is
returned and the callback invoked with it). This data is then supplied to the
root component and the new ui state calculated and rendered. Which is then
static till the next transaction or merge. This sounds rather inefficient, but
the way React is designed it&rsquo;s not in practice. Also om-next itself won&rsquo;t even
ask React to re-render a component if it decides that the props that are passed
to it haven&rsquo;t changed from the last time it was rendered.</p>

<p><a id="org3d88ebc"></a></p>
<h3 id='om-next'>Om-next</h3>
<p><a href="https://github.com/omcljs/om/wiki/Documentation-(om.next)">https://github.com/omcljs/om/wiki/Documentation-(om.next)</a></p>

<p><a id="org1c1dbe8"></a></p>
<h3 id='fulcro-handbook'>Fulcro handbook</h3>
<p><a href="http://book.fulcrologic.com">http://book.fulcrologic.com</a></p>

<p>Most of it is about how om-next itself works. The solutions for a more
practical om-next are a bit different in aum, and in some ways diverge somewhat
from the &rsquo;om-next way&rsquo; of doing things.</p>

<p><a id="orgd23da8b"></a></p>
<h3 id='see-om-next-docs-for-more-useful-links'>See om-next docs for more useful links</h3>
<p>Such as for graphql, falcor, datomic etc.</p>

<blockquote>
<p>Om-next by leveraging lisp and immutable values combines the best ideas of
graphql and falcor in a less cumbersome and more flexible manner.&ldquo;</p>
</blockquote>

<p><a id="orgef63e8b"></a></p>
<h2 id='install'>Install</h2>
<p>To pull in all the tools and libs to build an aum app add</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="n">aum</span><span class="w"> </span><span class="p">{</span><span class="no">:git/url</span><span class="w"> </span><span class="s">"https://github.com/michieljoris/aum.git"</span><span class="n">,</span><span class="w">
         </span><span class="no">:sha</span><span class="w"> </span><span class="s">"577daf362c3f81e08d43f654ef0bbf3ddc93e015"</span><span class="w">
         </span><span class="no">:tag</span><span class="w"> </span><span class="s">"master"</span><span class="p">}</span><span class="n">,</span><span class="w">
</span></code></pre>
<p>to your dependencies.</p>

<p>To actually build an app it&rsquo;s a good idea to start with a minimal setup, see the
following section.</p>

<p><a id="orged97ec0"></a></p>
<h2 id='starter-app'>Starter app</h2>
<p>There is a <a href="https://github.com/Michieljoris/aum-starter-app">repo</a> that&rsquo;s an app using aum libs, but has minimal content. This can
be used to try out building features/pages.</p>

<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    git clone https://github.com/Michieljoris/aum-starter-app.git
</code></pre>
<p>Clone it and follow the following instructions.</p>

<p><a id="org9756480"></a></p>
<h3 id='install-2'>Install</h3>
<p>Prerequisites:</p>

<ul>
<li>  mysql</li>
<li>  node</li>
<li>  nvm</li>
<li>  java 1.7 or greater</li>
</ul>

<p><a href="https://clojure.org/guides/getting_started">Install clojure</a></p>

<p>In the starter repo do:</p>

<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    nvm install
    nvm use
</code></pre>
<p>to make sure the proper version of node is used.</p>

<p>And then:</p>

<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    bin/dev-install
</code></pre>
<p>For development also do this:</p>

<p>Make sure pagora.aum, pagora.clj-utils and pagora.revolt repos are in the same parent dir as this repo.</p>

<p>So if this repo is in <code>~/src/aum-starter-app for example</code>, then you should
also have for instance <code>~/src/aum</code>  checked out to the most recent master.</p>

<p>TODO-aum: get this working properly!!!</p>

<p>This is so that tools.deps can resolve the dependencies locally. If you
want deps from github replace local-deps with git-deps in the bin/dev-backend script</p>

<p><a id="org1339c36"></a></p>
<h3 id='run-in-development-mode'>Run in development mode</h3>
<p>It&rsquo;s practical to run backend and frontend separately. It&rsquo;s rare you need
restart both, but being able to restarting one or the other sometimes is useful.
Also sometimes you only need or want to work on the backend.</p>

<p>After bin/dev-install:</p>

<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    bin/dev-backend
</code></pre>
<p>which will get you a clj repl in the terminal and an nrepl server.</p>

<p>To set config settings, for example the db, do:</p>

<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    <span class="nv">DB_NAME</span><span class="o">=</span>aum_dev bin/dev-backend
</code></pre>
<p>See config.clj for possible settings and their defaults (replace
hyphens with underscores and upcase the config key).</p>

<p>Connect your editor&rsquo;s repl to the nrepl server at port 5700.</p>

<p>In dev mode src-dev/clj/user.clj gets loaded (see resources/revolt.edn under the
revolt.plugin/rebel key). In deps.edn src-dev should be included in a paths
vector.</p>

<p>To compile the frontend, in another terminal do:</p>

<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    bin/dev-frontend
</code></pre>
<p>which will get you a cljs repl in your terminal.</p>

<p>See app at <a href="http://localhost:8080/app">localhost:8080/app</a></p>

<p>TODO-doc: test and document cljs repl</p>

<p>Alternatively start figwheel repl in emacs when running cider:
cider-jack-in-cljs (SPACE-m-&ldquo; in Doom emacs).</p>

<p>Entry point of backend in development is at clj.user ns. It has the lifecycle methods.</p>

<p>Entry point of frontend is at app.frontend.core. The aum/init fn initializes a
websocket and starts it. The react component tree gets mounted after websocket first
open event is received.</p>

<p><aside class="notice">
    NOTE: after building a prod jar, restart both backend and figwheel processes.
    This is because the out dir is cleaned before building and the dev versions of both css and js
    need to be built again. Or try modify a scss file and a cljs file to
    kickstart recompile.
    </aside></p>

<p><a id="org35eb161"></a></p>
<h3 id='run-in-production-mode'>Run in production mode</h3>
<p>TODO-aum: the build task doesn&rsquo;t include deps in aliases into the uberjar. Need to
fix the build task, so to create an uberjar uncomment the pagora.aum, pagora.revolt and
pagora.clj-utils deps in deps.edn.</p>

<p>Build production jar at <code>dist/app.ja</code> with:</p>

<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    bin/prod-build
</code></pre>
<p>This&rsquo;ll fetch node modules and build the js bundle as well.</p>

<p>Set database user/password/url/db-name, server port and ip, and what logs you would
like by setting the various environment variables and run jar (in dist dir):</p>

<p>TODO-aum: test starter app prod jar!!!</p>

<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    <span class="nv">CLJ_ENV</span><span class="o">=</span>prod <span class="nv">DB_USER</span><span class="o">=</span><span class="nb">test </span><span class="nv">DB_PASSWORD</span><span class="o">=</span>abc <span class="nv">DB_URL</span><span class="o">=</span><span class="s2">"//localhost:3306/"</span> <span class="nv">DB_NAME</span><span class="o">=</span>aum_dev <span class="nv">QUERY_LOG</span><span class="o">=</span><span class="nb">true </span><span class="nv">SQL_LOG</span><span class="o">=</span><span class="nb">true </span><span class="nv">HTTP_LOG</span><span class="o">=</span><span class="nb">false </span><span class="nv">SERVER_PORT</span><span class="o">=</span>8081 <span class="nv">SERVER_IP</span><span class="o">=</span>0.0.0.0 <span class="nv">NEW_RELIC_LICENSE_KEY</span><span class="o">=</span><span class="s2">"&lt;some newrelic key&gt;"</span> java -javaagent:./newrelic-agent.jar -Dnewrelic.config.file<span class="o">=</span>./newrelic.yml   -Dnewrelic.environment<span class="o">=</span>production -jar dist/aum.jarlk
</code></pre>
<p>or just</p>

<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    bin/prod-run
</code></pre>
<p>Or all in one cmd:</p>

<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    bin/prod-build-and-run
</code></pre>
<p><aside class="notice">
    If tools.deps complains about dirs already existing when cloning repos delete ~/.gitlibs.
    Clearing classpath cache in ~/.clojure might also help.
    </aside></p>

<p>See app at <a href="http://localhost:8080/app">localhost:8090/app</a></p>

<p>Entry point of backend in production is at app.core (the -main fn).</p>

<p><a id="org3c83c05"></a></p>
<h1 id='core-concepts'>Core concepts</h1>
<p><a id="org953459f"></a></p>
<h2 id='it-rsquo-s-om-next'>It&rsquo;s om-next.</h2>
<p>The idea is to stay as close as possible to the original idea of om-next as just
a thin layer on the top of react, but extend some concepts so at the very least
a straightforward crud app can be built really simply and quickly, with simple
tools to facilitate both front and backends development.</p>

<p>Om-next itself is isomorphic, meaning it can ran on either front or backend. Aum
extends om-next, and some of it can be used on both front and backend, but in
general it focuses more on making om-next useful in a practical way.</p>

<p>So in the backend the om-next parser is implemented to query a mysql database,
with security and validation mechanisms.</p>

<p>On the frontend aum implements a parser that in most cases will do the
right thing in denormalizing queries over the app state. And there are mechanism
for dealing with multiple remotes, websockets, error handling, correcting
optimistic updates etc.</p>

<p>Aum has its own thin layers over the reconciler and parser but still uses defui,
om/transact! etc</p>

<p><a id="org55c1daa"></a></p>
<h2 id='it-rsquo-s-a-loop'>It&rsquo;s a loop</h2>
<p>Frontend gui is a tree of ui components, with at the base the root component.
Every component declares in a query the data it needs to function. Parent
components compose their queries by adding the queries of its child
components to their own query. The root component thus is composed of a query in
the form of a tree of queries covering the data needs of the tree of gui components.</p>

<p>This query is fed to the reconciler together with the app state atom and the
parser. The query tree is parsed and processed with the current app state as the
source of data. The resulting tree of data is then passed to react to render the
gui. Any data not found in the current app state is queried for from a remote
over the network.</p>

<p>When any data is returned the app state is updated, query is run against the new
app state, the updated data tree is given again to React and the gui is updated
once more.</p>

<p>After the initial render the gui is only updated again when app state is
modified. This can happen through user actions, but also though data that comes
in from the network, either as a response to a query, or because data is pushed
from the server to the app.</p>

<p>Once app state is modified, query is run again, data tree built, fed to React
which rebuilds the gui. And once again the event driven system will be waiting
for app state updates.</p>

<p>This is a very broad outline with many details, optimizations and nuances left out, but
is the basic concept to hold in mind when designing and debugging a gui.</p>

<p><a id="org028a648"></a></p>
<h2 id='it-rsquo-s-just-a-sql-query'>It&rsquo;s just a sql query</h2>
<p>Or rather, a datomic pull query:</p>

<p>Currently the built in resolver for queries turns datomic pull queries into a
sql query string. This doesn&rsquo;t mean it&rsquo;s not possible to return data from
different sources but by default the assumption is that a query is mainly built
up as a nested query of joined tables, from and to any table.</p>

<p>Access to data is by default disallowed and an explicit configuration for every
table used needs to be defined and passed to aum before a query will return any
data. Access is role based.</p>

<p><a id="orga571920"></a></p>
<h2 id='it-rsquo-s-just-websockets'>It&rsquo;s just websockets</h2>
<p>If websockets are not available connection will fall back to ajax calls and
polling. See Sente library. Most communication will be through om queries, however
it&rsquo;s possible to define custom response handlers for non-om queries on both
front and backend. Advantage of websockets is push functionality, for instance
for notifications, or even to update frontend in response to backend database
updates by other clients.</p>

<p><a id="orgc4208aa"></a></p>
<h2 id='we-pretend-we-have-all-data-already-in-the-frontend'>We pretend we have all data already in the frontend</h2>
<p>When defining queries for components ask for all data the component could
possibly need. The root query will be automatically resolved against the app
state and generate data for the gui tree and queries for all remotes.</p>

<p>However we very likely might not want to resolve a query in its totality every
time. For instance if we have more than one page we don&rsquo;t need to produce data
for pages we&rsquo;re not currently showing. Neither do we care to fetch data for
those pages. A good place to store the information on what we care about and
what not at any given moment is app state itself. For instance we might have a
key :app/page in app state.</p>

<p>We write multimethods that dispatch on target (value or a remote) and keyword.
For instance:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">page</span><span class="w"> </span><span class="p">[</span><span class="no">:page/some-page</span><span class="w"> </span><span class="no">:page/some-other-page</span><span class="p">]]</span><span class="w">
      </span><span class="p">(</span><span class="nf">aum/derive-om-query-key!</span><span class="w"> </span><span class="n">page</span><span class="w"> </span><span class="no">:page/*</span><span class="p">))</span><span class="w">

    </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">aum/read</span><span class="w"> </span><span class="p">[</span><span class="no">:value</span><span class="w"> </span><span class="no">:page/*</span><span class="p">]</span><span class="w">
      </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">state</span><span class="w"> </span><span class="n">context-data</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="n">db-&gt;tree</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">env</span><span class="p">}</span><span class="w"> </span><span class="n">page</span><span class="w"> </span><span class="n">params</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">current-page</span><span class="w"> </span><span class="p">(</span><span class="no">:app/page</span><span class="w"> </span><span class="err">@</span><span class="n">state</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">current-page</span><span class="w"> </span><span class="n">page</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nf">db-&gt;tree</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="p">{</span><span class="no">:query</span><span class="w"> </span><span class="n">query</span><span class="w">
                         </span><span class="no">:data</span><span class="w">  </span><span class="n">context-data</span><span class="w">
                         </span><span class="no">:refs</span><span class="w">  </span><span class="err">@</span><span class="n">state</span><span class="p">}))))</span><span class="w">

    </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">aum/read</span><span class="w"> </span><span class="p">[</span><span class="no">:my-remote</span><span class="w"> </span><span class="no">:page/*</span><span class="p">]</span><span class="w">
      </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">state</span><span class="w"> </span><span class="n">default-remote</span><span class="w"> </span><span class="n">context-data</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="n">ast</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">env</span><span class="p">}</span><span class="w"> </span><span class="n">page</span><span class="w"> </span><span class="n">params</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">current-page</span><span class="w"> </span><span class="p">(</span><span class="no">:app/page</span><span class="w"> </span><span class="err">@</span><span class="n">state</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">current-page</span><span class="w"> </span><span class="n">page</span><span class="p">)))</span><span class="w">
</span></code></pre>
<p>In standard om-next you write read methods to resolve the root keys or the root
query. In aum you write methods that allow custom resolving of keys <em>anywhere</em>
in the root query for both value and remotes.</p>

<p>The db-&gt;tree fn is adapted from the one from om-next and is the default read
method used in the parser. Without defining any custom aum/read methods the
db-&gt;tree fn actually behaves the same way as the standard om-next db-&gt;tree fn.</p>

<p>The actual read function passed to the om parser basically does this:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">(</span><span class="nf">db-&gt;tree</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="p">{</span><span class="no">:query</span><span class="w"> </span><span class="n">root-component-query</span><span class="w">
                   </span><span class="no">:data</span><span class="w">  </span><span class="n">app-state</span><span class="w">
                   </span><span class="no">:refs</span><span class="w">  </span><span class="n">app-state</span><span class="p">})</span><span class="w">
</span></code></pre>
<p>In practice this allows us to have total control over what we return as data to
the gui component tree and what queries we send to our remotes for any key
anywhere in the root query every time we do our &rsquo;loop&rsquo;.</p>

<p>As in the &rsquo;routing&rsquo; example the best place to store information to &rsquo;direct&rsquo; our
read methods is in app state. To further differentiate between similarly named
keys in our root key we can wrap our query expressions with parameters (when we
define them in components).</p>

<p><a id="orgba7807a"></a></p>
<h2 id='om-next-mutations-almost'>Om-next mutations, almost</h2>
<p>You either mutate frontend app-state:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">mutate</span><span class="w"> </span><span class="ss">'admin/set-key</span><span class="w">
      </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">env</span><span class="p">}</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="nb">key</span><span class="w"> </span><span class="n">value</span><span class="p">]}]</span><span class="w">
      </span><span class="p">{</span><span class="no">:action</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w">
                 </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="nb">assoc</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="n">value</span><span class="p">))})</span><span class="w">

</span></code></pre>
<p>So just return a map with an action. In that action fn you have access to the
app state as an atom.</p>

<p>And/or you set a key that&rsquo;s a defined remote in the returned map to true:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">mutate</span><span class="w"> </span><span class="ss">'app/test</span><span class="w">
      </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">state</span><span class="p">]}</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">p1</span><span class="w"> </span><span class="n">p2</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">params</span><span class="p">}]</span><span class="w">
      </span><span class="p">{</span><span class="no">:my-remote</span><span class="w"> </span><span class="n">true</span><span class="w">
       </span><span class="no">:post-remote</span><span class="w"> </span><span class="p">{</span><span class="no">:param-keys</span><span class="w"> </span><span class="p">[</span><span class="n">p1</span><span class="w"> </span><span class="n">p2</span><span class="p">]</span><span class="w">
                     </span><span class="no">:params</span><span class="w"> </span><span class="p">{</span><span class="no">:p3</span><span class="w"> </span><span class="mi">123</span><span class="p">}}</span><span class="w">
       </span><span class="no">:action</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="ss">'...</span><span class="p">)})</span><span class="w">
</span></code></pre>
<p>You&rsquo;ll have to handle this mutation in the backend.</p>

<p>Sometimes however you would like to a take some extra action <span class="underline">after</span> a remote
mutation has finished and the data has been returned. For every mutation method
you can define a same name post-remote method. This is called with the value as
returned from the backend. Here you can do error handling for instance or &rsquo;clean
up&rsquo; the response <em>before</em> it get merged with app state.</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">post-remote</span><span class="w"> </span><span class="ss">'app/test</span><span class="w">
      </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="n">state</span><span class="w">
       </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">error</span><span class="w"> </span><span class="nb">keys</span><span class="p">]</span><span class="w">
        </span><span class="p">{{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">p1</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="n">p3</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">params</span><span class="p">}</span><span class="w"> </span><span class="no">:params</span><span class="p">}</span><span class="w"> </span><span class="no">:post-remote</span><span class="w">
        </span><span class="no">:as</span><span class="w"> </span><span class="n">value</span><span class="p">}]</span><span class="w">
      </span><span class="c1">;;Do something!!</span><span class="w">
      </span><span class="p">)</span><span class="w">
</span></code></pre>
<p>The :post-remote key in the mutation is a mechanism to pass data to the post
remote method from the mutation. TODO-aum: there might be a better mechanism for
this. At the moment this involves the backend, but it is purely a frontend
concern.</p>

<p><a id="orge8ea368"></a></p>
<h2 id='integrant-for-state-managment'>Integrant for state managment</h2>
<p>TODO-aum: add link to integrant.
TODO-aum: add a way so an app can add it&rsquo;s own state-full components.
TODO-aum: add a hook for when app is done initializing</p>

<p><a id="orge122903"></a></p>
<h2 id='not-boot-not-lein-but-tools-deps'>Not boot, not lein but tools.deps</h2>
<p>&#x2026;to develop and build the app</p>

<p>All dependencies are declared in deps.edn. For executing various tasks for
developing and building the app, and for creating a development environment
<a href="https://github.com/mbuczko/revolt">revolt</a> is used. Its configuration is in resources/revolt.edn. Various custom
tasks are defined in bilby.revolt namespaces. Figwheel has its own config in
figwheel.main.edn main.cljs.edn. At the moment the cljs compiler config is
duplicated in revolt.den and main.cljs.edn. It&rsquo;s on the todo list to fix that.
It all comes together in the build and run scripts in the bin dir.</p>

<p><a id="org1c104bc"></a></p>
<h1 id='build-system'>Build system</h1>
<p>Aum itself is a tools.deps project</p>

<p>For compile, nrepl, and other build and developing time concerns the aum starter
app uses <a href="https://github.com/mbuczko/revolt">revolt</a>:</p>

<blockquote>
<p>revolt is a plugins/tasks oriented library which makes it easier to integrate
beloved dev tools like nrepl, rebel readline or clojurescript into application,
based on Cognitect&rsquo;s command line tools.</p>
</blockquote>

<p>A slight adaption of revolt and modified and new tasks are in the <a href="http://github.com/Michieljoris/revolt">pagora.revolt</a>
repo. The source code of revolt is very readable and extendable with more tasks
and plugins.</p>

<p>In the bin directory of the aum starter app is a set of build and dev scripts.</p>

<p>Also, npm modules can be added to the the project by adding them to package.json
,webpacking them, and adding any externs. The whole webpacked js file is added as a
foreign lib in the compiler configuration. There&rsquo;s scripts and examples in the
repo. Trickiest might be to create an extern file, however there&rsquo;s tools to
automate that (TODO-doc links?). See later section for more details.</p>

<p><a id="orgf503e02"></a></p>
<h1 id='app-starting-process'>App starting process</h1>
<p><a id="orgb52f455"></a></p>
<h2 id='dev'>dev</h2>
<p><a id="orgf5a9abe"></a></p>
<h3 id='backend'>Backend</h3>
<p>When calling <code>bin/dev-backend</code> the last plugin (rebel) is configured in
resources/revolt.edn under the <code>:revolt.plugin/rebel.init-ns</code> key to load the clj.user
namespace.</p>

<p>In clj.user a restart fn is defined that inits aum, inits a integrant system
with it and then calls <code>(dev/go)</code> on it. This kicks of all the init-key fns in the
various namespaces (db, server etc).</p>

<p><a id="orgbe39325"></a></p>
<h3 id='frontend'>Frontend</h3>
<p>When starting figwheel (by either <code>bin/dev-figwheel</code> or <code>space-m-&quot;</code> in Emacs) the
compiler options in dev.cljs.edn get used to produce the js from cljs. The :main
option is set to cljs.user. This is the first file loaded in the frontend by
goog.require and all the dependent files are loaded after that. cljs.user should
require app.frontend.core. In that namespace aum is initialized with the root
component and the initial app state. The returned aum config is then passed to
<code>pagora.aum.frontend.core/go</code> fn.</p>

<p><a id="orga8ab1e8"></a></p>
<h2 id='prod'>prod</h2>
<p><a id="org351d286"></a></p>
<h3 id='backend-2'>Backend</h3>
<p>When building the production jar the pagora.revolt.task/capsule is used. The
configuration for that task specifies the app.core namespace as the main
namespace.</p>

<p><a id="orge5d2298"></a></p>
<h3 id='frontend-2'>Frontend</h3>
<p>When building the production jar using revolt the cljs compiler options in
resources/revolt.edn are used. In there the main key is set to
<code>app.frontend.core</code>, bypassing cljs.user. After that the process is the same as in
dev mode. See the bin/prod-run script for an example how to actually run the
production jar.</p>

<p><a id="orgfef1aaa"></a></p>
<h1 id='environment'>Environment</h1>
<p>You can require <code>pagora.aum.environment</code> in both front and backend. The current
environment is in the <code>pagora.aum.environment/environment</code> var or call functions
like <code>is-development?</code> from that namespace. The default environment is :dev. Start
the app with <code>CLJ_ENV=[production|staging|testing|dev]</code> to set the environment.</p>

<p><a id="orgbf557fb"></a></p>
<h1 id='config'>Config</h1>
<p>Config is defined in multimethods like this, for instance in app.config:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">app.config</span><span class="p">)</span><span class="w">

    </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">aum/config</span><span class="w"> </span><span class="no">:common</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="w">
      </span><span class="p">{</span><span class="no">:timbre-log-level</span><span class="w"> </span><span class="no">:error</span><span class="w">
       </span><span class="no">:app-path</span><span class="w"> </span><span class="s">"app/"</span><span class="p">})</span><span class="w">

    </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">aum/config</span><span class="w"> </span><span class="no">:dev</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="w">
      </span><span class="p">{</span><span class="no">:timbre-level</span><span class="w"> </span><span class="no">:info</span><span class="w">
       </span><span class="no">:frontend-config-keys</span><span class="w"> </span><span class="p">[</span><span class="no">:app-path</span><span class="w"> </span><span class="no">:timbre-level</span><span class="p">]})</span><span class="w">
</span></code></pre>
<p>Any env variable set on command line will override any hardcoded setting in
app.config. For this reason any keys in any config map will have to be scalar
values. Because bash env vars are scalar values (numbers, strings etc).</p>

<p>You pass the namespaces these methods are defined to aum (eg. app.config). Any
config defined in :common will be merged with config for the current environment
with the latter overriding keys in the former. This config is then used in aum
and can be requested from aum (aum.core/get-config). Aum groups some of these
keys already (eg. under :mysql-database, :nrepl, :server), if you want to group
other keys or in general want to process the config before it gets used in the
app as returned from get-config pass a preprocess-config fn to aum. TODO-aum:
implement!</p>

<p>Frontend config works similarly, so also with multimethods.</p>

<p>Keys listed in the backend under <code>:frontend-config-keys</code> will be sent to the
frontend and merged into the frontend config before the app starts.</p>

<p>When starting up a jar you will need to set the clj-env environment variable,
also see bin/prod-run . There&rsquo;s a <code>CLJ_ENV=prod</code> in the bin/prod-build script, but
this has only effect on the build. Not the running of the program (when running
the jar).</p>

<p>Call get-config if you need settings. However in aum parser read and mutate
methods the config is part of the env param passed in as :parser-config. Better
to use that so it can be more easily mocked in tests. TODO-aum: ??? is this so?</p>

<p>See <code>pagora.aum.config/default-config</code> and <code>pagora.aum.config/parser-config</code> for all
settings that can be overridden/set on the commandline, besides the ones as set
in app.config.</p>

<p><a id="orgc2a531a"></a></p>
<h1 id='websockets'>Websockets</h1>
<p>TODO-doc: more info on how to use websockets for any custom communication
between front and backend</p>

<p><a id="org561ccef"></a></p>
<h1 id='database'>Database</h1>
<p>Currently <a href="https://www.hugsql.org/">hugsql</a> is to create parameterized sql query functions used in the
backend. There&rsquo;s a pagora.aum.database.build-sql namespace that doesn&rsquo;t depend
on hugsql and creates the jdbc query strings similarly but is so far only used
for <a href="https://github.com/agershun/alasql">alasql</a>. Alasql is used in full stack testing where it&rsquo;s possible to run the
backend in the frontend.</p>

<p>In any case, the sql function in <code>pagora.database.query/sql</code> takes a keyword
referring to a predefined hugsql function. This sql function calls several
multimethods to process parameter input, validation and process query output.</p>

<p><a id="org709a4a9"></a></p>
<h2 id='validation'>Validation</h2>
<p>Idea is that for every hugsql function added you will have to write a
validate-sql-fun method otherwise it will throw an exception when its called
through <code>pagora.database.query/sql</code>. You can write an empty method, and then no
validation is done. You can do validation right there and then, or you can
retrieve an appropriate validation fn by calling security/get-validation-fun.
You will probably wil have to add a fn to database.config or add an appropriate
aum.database.validate.core/validate method. Otherwise, again, an exception is
thrown by default.</p>

<p>Every call to the sql function in the <code>pagora.aum.database.query</code> namespace by
default is validated by calling the aum validate-sql-fn multimethod. This
dispatches on sql function keyword. For all mutating sql queries as defined in
the pagora.aum.database.queries namespace the proper validation function is
retrieved using <code>pagora.aum.security/get-validation-fun</code>. This can be set in the
<code>app.database.config</code>. If the standard aum save-record is used the multimethod
<code>pagora.aum.database.validate.core/validate</code> multimethod is called, dispatching
on role of the user, method (sql fn keyword). Extend this method for tables you
want created/deleted/updated.</p>

<p>A simple database config for a user table for example is this:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">schema</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="no">:int</span><span class="w">
                 </span><span class="no">:name</span><span class="w"> </span><span class="no">:text</span><span class="w">
                 </span><span class="no">:email</span><span class="w"> </span><span class="no">:text</span><span class="w">
                 </span><span class="no">:active</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="no">:boolean</span><span class="p">}})</span><span class="w">

    </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="p">{</span><span class="no">:root</span><span class="w"> </span><span class="n">true</span><span class="w">
                 </span><span class="no">:schema</span><span class="w"> </span><span class="n">schema</span><span class="w">
                 </span><span class="no">:columns</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">schema</span><span class="p">)</span><span class="w">
                 </span><span class="no">:read</span><span class="w"> </span><span class="p">{</span><span class="no">:blacklist</span><span class="w"> </span><span class="p">[]}})</span><span class="w">

    </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">av/validate</span><span class="w"> </span><span class="p">[</span><span class="s">"some-role"</span><span class="w"> </span><span class="no">:create</span><span class="w"> </span><span class="no">:user</span><span class="p">]</span><span class="w">
      </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">env</span><span class="p">}</span><span class="w">  </span><span class="n">new-record</span><span class="w"> </span><span class="n">_</span><span class="p">]</span><span class="w">
      </span><span class="c1">;;Throw an exception and the creation of the user will be cancelled</span><span class="w">
      </span><span class="p">)</span><span class="w">

    </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">av/validate</span><span class="w"> </span><span class="p">[</span><span class="s">"some-role"</span><span class="w"> </span><span class="no">:update</span><span class="w"> </span><span class="no">:user</span><span class="p">]</span><span class="w">
      </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">env</span><span class="p">}</span><span class="w">  </span><span class="n">current-record</span><span class="w"> </span><span class="n">mods</span><span class="w"> </span><span class="n">updated-record</span><span class="p">]</span><span class="w">
      </span><span class="c1">;;Throw an exception and the updating of the user will be cancelled</span><span class="w">
      </span><span class="p">)</span><span class="w">
</span></code></pre>
<p>The user passed in the env map is set to the logged in user.</p>

<p><a id="org4af4e3d"></a></p>
<h2 id='processing-parameters-and-results'>Processing parameters and results</h2>
<p>In essence all the database.query/sql fn does is first call the multimethods
 <code>aum-process-params</code>, then <code>process-params</code> on the params, call <code>validate-sql</code>
 then call the actual hugsql fn and then call <code>aum-process-result</code> and then
 <code>process-params</code> on the result, all in the <code>pagora.aum.database.query</code>
 namespace.</p>

<p>The <code>aum-process-params</code> does some built-in params processing, same for
<code>aum-process-result</code>. Custom versions of these fns will be used if set in the
sql prop of env.</p>

<p><code>process-params</code> does nothing by default, <code>process-result</code> just returns result as
passed in.</p>

<p><code>pagora.aum.database.queries</code> namespace is used to resolve the hugsql function.</p>

<p>It&rsquo;s also possible to add an extra hugsql ns for resolving the sql fn.
(aum-)process-params, (aum-)process-result and validate-sql-fun are all
multimethods so you can add methods to deal with any extra hugsql fns.</p>

<p>process-params (and process-result) is handy for adding hooks. For instance for
an event-store. For more detail see also doc string of database.query/sql fn.</p>

<p>There&rsquo;s also a pagrora.aum.database.query/table-hook multimethod:</p>

<p>#+begin<sub>quote</sub>
Receives env, fun, params and processed result. Dispatches on fun and table-keyword if
set in params. Return is ignored. Meant for side effects
#+end<sub>quote</sub>.</p>

<p>You&rsquo;d have to set the table-keyword in params in process-params.</p>

<p><a id="org4130808"></a></p>
<h1 id='frontend-matters'>Frontend matters</h1>
<p><a id="orgd4ec91d"></a></p>
<h2 id='generic-recursive-read-with-hooks'>Generic recursive read with hooks</h2>
<p><a id="orged9999f"></a></p>
<h3 id='intro-2'>Intro</h3>
<ol>
<li><p>Combining queries</p>

<p>In om-next the root query is composed of sub queries recursively as they&rsquo;re
pulled from components. However not every component necessarily represents a
database row, or sequence of rows of a database table. Sometimes a component is
just a grouping of other components. These components still need their own
queries. A natural way of doing that is to use placeholder keys. Both front and
backend parsers skip over these keys and just keep parsing and trying to return
values for deeper nested keys instead. In the case of the backend if a key is
not a table as set in the database config it will ignore it. In the frontend the
parser just grabs the value of the key if it exists in the app state and keeps
parsing.</p></li>
<li><p>Finetuning parser result</p>

<p>In om-next for every render the complete root query is applied over the
app-state (basically the same as the om-next function db-&gt;tree). This works fine
for a small and simple app, however as an app gets more complicated you would
like to have a bit more control of what gets returned for a key and/or if a key
is included in any remote query. A standard om-next parser only implements
reading the root query keys. In other words, it&rsquo;s not recursive. The aum parser
recursively tries to interprete a query and will call any hooks for keys if they
exist. So at any time during the parsing of a query you can insert your own code
for resolving values and any remote. If you want to keep resolving any deeper
nested queries in your read method for a key you can call the supplied db-&gt;tree
passed in the env (similar to how you received the parser in standard om-next).</p>

<p>Standard om-next has something similar called dynamic queries. This extends this
idea by letting you respond to app-state changes and changing what gets returned
for any key anywhere in a query for both value and any remote, in other words
any (sub-)query can become &rsquo;dynamic&rsquo; by defining a read method for it.</p>

<p>For instance you can set the selected-id in app state to 123. In your
selected-record component add a generic query for a record such as this:</p></li>
</ol>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">        </span><span class="p">[({</span><span class="no">:user</span><span class="w"> </span><span class="p">[</span><span class="no">:id</span><span class="w"> </span><span class="no">:name</span><span class="p">]}</span><span class="w"> </span><span class="p">{</span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="no">:id</span><span class="w"> </span><span class="no">:=</span><span class="w"> </span><span class="n">nil</span><span class="p">]})]</span><span class="w">
</span></code></pre>
<p>and a remote read method for :user where you modify the remote query&rsquo;s params and set
    the selected id (123 in our example).</p>

<p>Again, the value itself that&rsquo;s returned to the app can be customized by adding a
    value read for the same key for example because you want to calculate a client
    side prop and add it to the value.</p>

<p><a id="org6f567e2"></a></p>
<h3 id='adding-hooks-for-keys-and-joins-in-the-root-query-for-returning-values-and-building-remote-query'>Adding hooks for keys and joins in the root query for returning values and building remote query</h3>
<ol>
<li><p>Principles</p>

<p>The standard read method of aum is db-&gt;tree of om-next. This will return a
tree of data by applying the root query over the app-state. The stock om-next
db-&gt;tree fn has been extended in the following ways:</p>

<ol>
<li> It&rsquo;s possible to define read methods for any key anywhere in the query. If
you do you can then return anything you want for that key. You will get in
the env the ast for the om-next expression (join or prop), the query if it&rsquo;s
a join, context-data and (app-)state. Context data is the data relevant for
the prop or join, which depends on where in the root query the key for the
join or prop is. For instance the default way to resolve a prop is just to do
(get context-data key). Default way to resolve a join is db-&gt;tree on the
query and context-data (see <code>pagora.aum.reconciler.parser.key.page</code> and the read
method for [:value :page/*]).</li>
<li> The db-&gt;tree fn has been modified so that instead of returning data it&rsquo;ll
return the query again, but &rsquo;sparsified&rsquo; when :sparsify-query? flag is
set. By default if any data is found that part of the query is elided. But
again you can add read methods to determine yourself if and what should be
included for any key in the root query. In standard om you need to return
a (possibly modified) ast. For these aum read methods to work you return a
(modified) query instead. Whatever you return will be included in the
remote query. If you want to process and modify the ast you can you just
do a (om/ast-&gt;query ast) when you&rsquo;re done editing it. You can also return
true which will then result in the query being parsed further the standard
db-&gt;tree way. Note that currently if the key is a prop only the truthiness
of the return value is used. If truthy the return key is included,
otherwise it isn&rsquo;t. Return the full query in case of a join. So for a read
method for [:aum :foo] you return {:foo [:some :query]}. If query had
params you can add them again, possibly modified.</li>
<li> Read method is dispatched on key, or on [target key]. Second one takes
preference over first. In the first instance you need to return a map such as
{:value :some-value :aum {:some-key [:some :query]}} similar to standard
om-next read methods.</li>
</ol></li>
<li><p>Examples</p>

<ol>
<li><p>VALUE example</p>

<p>The method (note the :value in the dispatch vector):</p></li>
</ol></li>
</ol>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">            </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">aum/read</span><span class="w"> </span><span class="p">[</span><span class="no">:value</span><span class="w"> </span><span class="no">:bar</span><span class="p">]</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">query</span><span class="w"> </span><span class="n">context-data</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">env</span><span class="p">}</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="n">params</span><span class="p">]</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre>
<p>for a app state structure like this:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">            </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="p">{</span><span class="no">:bar</span><span class="w"> </span><span class="p">{</span><span class="no">:k1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:k2</span><span class="w"> </span><span class="mi">2</span><span class="p">}}}</span><span class="w">
</span></code></pre>
<p>and a root query of:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">            </span><span class="p">[{</span><span class="no">:foo</span><span class="w"> </span><span class="p">[{</span><span class="no">:bar</span><span class="w"> </span><span class="p">[</span><span class="no">:k1</span><span class="w"> </span><span class="no">:k2</span><span class="w"> </span><span class="no">:k3</span><span class="p">]}]}]</span><span class="w">
</span></code></pre>
<p>receives env like this:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">            </span><span class="p">{</span><span class="no">:query</span><span class="w"> </span><span class="p">[</span><span class="no">:k1</span><span class="w"> </span><span class="no">:2</span><span class="p">]</span><span class="w">
             </span><span class="no">:context-data</span><span class="w"> </span><span class="p">{</span><span class="no">:k1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:k2</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
             </span><span class="no">:ast</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="no">:join,</span><span class="w"> </span><span class="no">:dispatch-key</span><span class="w"> </span><span class="no">:bar,</span><span class="w"> </span><span class="no">:key</span><span class="w"> </span><span class="no">:bar,</span><span class="w"> </span><span class="no">:query</span><span class="w"> </span><span class="p">[</span><span class="no">:k1</span><span class="w"> </span><span class="no">:k2</span><span class="p">]</span><span class="n">,</span><span class="w">
                   </span><span class="no">:children</span><span class="w"> </span><span class="p">[{</span><span class="no">:type</span><span class="w"> </span><span class="no">:prop,</span><span class="w"> </span><span class="no">:dispatch-key</span><span class="w"> </span><span class="no">:k1,</span><span class="w"> </span><span class="no">:key</span><span class="w"> </span><span class="no">:k1</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="no">:prop,</span><span class="w"> </span><span class="no">:dispatch-key</span><span class="w"> </span><span class="no">:k2,</span><span class="w"> </span><span class="no">:key</span><span class="w"> </span><span class="no">:k2</span><span class="p">}]}</span><span class="w">
             </span><span class="n">...</span><span class="w">
             </span><span class="p">}</span><span class="w">
</span></code></pre>
<p>and should return for example this:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">            </span><span class="p">{</span><span class="no">:k1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:k2</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
</span></code></pre>
<p>2.  REMOTE example</p>

<p>The method (note the :aum in the dispatch vector):</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">            </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">aum/read</span><span class="w"> </span><span class="p">[</span><span class="no">:aum</span><span class="w"> </span><span class="no">:bar</span><span class="p">]</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">query</span><span class="w"> </span><span class="n">context-data</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">env</span><span class="p">}</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="n">params</span><span class="p">]</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre>
<p>for a app state structure like this:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">            </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="p">{</span><span class="no">:bar</span><span class="w"> </span><span class="p">{</span><span class="no">:k1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:k2</span><span class="w"> </span><span class="mi">2</span><span class="p">}}}</span><span class="w">
</span></code></pre>
<p>and a root query of:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">            </span><span class="p">[{</span><span class="no">:foo</span><span class="w"> </span><span class="p">[{</span><span class="no">:bar</span><span class="w"> </span><span class="p">[</span><span class="no">:k1</span><span class="w"> </span><span class="no">:k2</span><span class="w"> </span><span class="no">:k3</span><span class="p">]}]}]</span><span class="w">
</span></code></pre>
<p>receives env like this:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">            </span><span class="p">{</span><span class="no">:query</span><span class="w"> </span><span class="p">[</span><span class="no">:k1</span><span class="w"> </span><span class="no">:k2</span><span class="w"> </span><span class="no">:k3</span><span class="p">]</span><span class="w">
             </span><span class="no">:context-data</span><span class="w"> </span><span class="p">{</span><span class="no">:k1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:k2</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
             </span><span class="no">:ast</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="no">:join,</span><span class="w"> </span><span class="no">:dispatch-key</span><span class="w"> </span><span class="no">:bar,</span><span class="w"> </span><span class="no">:key</span><span class="w"> </span><span class="no">:bar,</span><span class="w"> </span><span class="no">:query</span><span class="w"> </span><span class="p">[</span><span class="no">:k1</span><span class="w"> </span><span class="no">:k2</span><span class="p">]</span><span class="n">,</span><span class="w">
                   </span><span class="no">:children</span><span class="w"> </span><span class="p">[{</span><span class="no">:type</span><span class="w"> </span><span class="no">:prop,</span><span class="w"> </span><span class="no">:dispatch-key</span><span class="w"> </span><span class="no">:k1,</span><span class="w"> </span><span class="no">:key</span><span class="w"> </span><span class="no">:k1</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="no">:prop,</span><span class="w"> </span><span class="no">:dispatch-key</span><span class="w"> </span><span class="no">:k2,</span><span class="w"> </span><span class="no">:key</span><span class="w"> </span><span class="no">:k2</span><span class="p">}]}</span><span class="w">
             </span><span class="n">...</span><span class="w">
             </span><span class="p">}</span><span class="w">
</span></code></pre>
<p>and should return for example this:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">            </span><span class="p">{</span><span class="no">:bar</span><span class="w"> </span><span class="p">[</span><span class="no">:k3</span><span class="p">]}</span><span class="w">
</span></code></pre>
<p>to create a remote query like this:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">            </span><span class="p">[{</span><span class="no">:foo</span><span class="w"> </span><span class="p">[{</span><span class="no">:bar</span><span class="w"> </span><span class="p">[</span><span class="no">:k3</span><span class="p">]}]}]</span><span class="w">
</span></code></pre>
<p>If you want to keep the params (or add, or modify) return something like this:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">            </span><span class="p">(</span><span class="nf">cond-&gt;</span><span class="w"> </span><span class="p">{</span><span class="no">:bar</span><span class="w"> </span><span class="p">[</span><span class="no">:k3</span><span class="p">]}</span><span class="w">
              </span><span class="p">(</span><span class="nf">some?</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">params</span><span class="p">)</span><span class="w">
</span></code></pre>
<p>3.  Routing</p>

<p>Sometimes you would like to only load (send with the remote) a particular
        segment of a root query, for instance based on route or page that the user
        selected to display. By setting the selected page in app state you can (by using
        key inheritance and multimethods) only return a remote for a key that matches
        that page:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">            </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">aum/read</span><span class="w"> </span><span class="p">[</span><span class="no">:value</span><span class="w"> </span><span class="no">:page/*</span><span class="p">]</span><span class="w">
              </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">state</span><span class="w"> </span><span class="n">default-remote</span><span class="w"> </span><span class="n">context-data</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="n">db-&gt;tree</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">env</span><span class="p">}</span><span class="w"> </span><span class="n">page</span><span class="w"> </span><span class="n">params</span><span class="p">]</span><span class="w">
              </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">current-page</span><span class="w"> </span><span class="p">(</span><span class="no">:app/page</span><span class="w"> </span><span class="err">@</span><span class="n">state</span><span class="p">)]</span><span class="w">
                </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">current-page</span><span class="w"> </span><span class="n">page</span><span class="p">)</span><span class="w">
                  </span><span class="p">(</span><span class="nf">db-&gt;tree</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="p">{</span><span class="no">:query</span><span class="w"> </span><span class="n">query</span><span class="w">
                                 </span><span class="no">:data</span><span class="w">  </span><span class="n">context-data</span><span class="w">
                                 </span><span class="no">:refs</span><span class="w">  </span><span class="err">@</span><span class="n">state</span><span class="p">}))))</span><span class="w">

            </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">aum/read</span><span class="w"> </span><span class="p">[</span><span class="no">:remote</span><span class="w"> </span><span class="no">:page/*</span><span class="p">]</span><span class="w">
              </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">env</span><span class="p">}</span><span class="w"> </span><span class="n">page</span><span class="w"> </span><span class="n">params</span><span class="p">]</span><span class="w">
              </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">current-page</span><span class="w"> </span><span class="p">(</span><span class="no">:app/page</span><span class="w"> </span><span class="err">@</span><span class="n">state</span><span class="p">)]</span><span class="w">
                </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">current-page</span><span class="w"> </span><span class="n">page</span><span class="p">)))</span><span class="w">

            </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">page</span><span class="w"> </span><span class="p">[</span><span class="no">:page/some-page</span><span class="w"> </span><span class="no">:page/some-other-page</span><span class="p">]]</span><span class="w">
              </span><span class="p">(</span><span class="nf">aum/derive-om-query-key!</span><span class="w"> </span><span class="n">page</span><span class="w"> </span><span class="no">:page/*</span><span class="p">))</span><span class="w">
</span></code></pre>
<p>This implements basic &rsquo;routing&rsquo;.</p>

<p>4.  Pagination</p>

<p>Set the query for the items you want to display paginated (or with infinite
        scroll) in the relevant component. This will by default fetch all available
        records (or as many as the server is willing to send in one batch). This is not
        what we want so we add a hook for the query for that component. In that query we
        add the proper params (such as limit, offset etc). These values will (should)
        have been set in app state with a mutation (triggered by a scroll or click of
        pagination button). Now only the records for a particular page are fetched. If
        we are paginating this is enough. If we are scrolling we need to &rsquo;cache&rsquo; the
        list of idents already in place for our key from a previous query. Then on read
        of that key we need to prefix the cached list of idents to the actual list of
        idents received from the backend.</p>

<p>5.  Autocomplete</p>

<p>Add a hook for the key for the autocomplete component. Return nil for any remote
        and it will not be added to the root remote query Once a search term is set in
        app state we adjust the query for the autocomplete component and add the right
        params (eg. {:where [:name :like &ldquo;%my search%&rdquo;]}). This will make data avaliable
        for the autocomplete component to display in its dropdown. This search term in
        app state will have to cleared when navigating away from the page otherwise it
        will be acted on again when returning to the page with the autocomplete.</p>

<ol>
<li> Notes</li>
</ol>

<p>-   If you set ignore-hooks? to true db-&gt;tree will function as the standard om-next</p>

<p>db-&gt;tree, but by setting :sparsify-query? to true you can still also calculate
    the remote query.</p>

<p>-   In <code>pagora.aum.reconciler.parser.denormalize</code> there&rsquo;s a comment block where you can</p>

<p>play around with db-&gt;tree. There&rsquo;s also the try-frontend-read ns.</p>

<p>-   To see the whole process in all its glory set timbre-level to :debug in</p>

<p>app.config.cljs and set the chrome dev console to verbose output.</p>

<p>_ For read methods the parser is not available in the env, but db-&gt;tree is.</p>

<p>Use of that is simple:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">        </span><span class="p">(</span><span class="nf">db-&gt;tree</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="p">{</span><span class="no">:query</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="c1">;;Apply this query</span><span class="w">
                       </span><span class="no">:data</span><span class="w">  </span><span class="n">data</span><span class="w"> </span><span class="c1">;;to this data</span><span class="w">
                       </span><span class="no">:refs</span><span class="w">  </span><span class="n">app-data</span><span class="w"> </span><span class="c1">;;looking up idents (refs) here.</span><span class="w">
                       </span><span class="no">:sparsify-query?</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="c1">;;Return the data, not a sparsified query</span><span class="w">
                       </span><span class="no">:ignore-hooks?</span><span class="w"> </span><span class="n">false</span><span class="p">})</span><span class="w">
</span></code></pre>
<p><a id="org8744aaf"></a></p>
<h2 id='client-only-keys'>Client only keys</h2>
<p>Any key with a namespace that starts with :client will never be sent to the
backend. The value for any key with the namespace :client will be looked up in
the root of app state. So that means that for instance the key :client-prop/name
will not be sent to the backend either. But will still be looked up in the
context data for that key.</p>

<p><a id="org6b58eae"></a></p>
<h2 id='make-cmp-and-om-data'>make-cmp and om-data</h2>
<p>Use pagora.aum.frontend.util/make-cmp function to create a function that you can
use in your render function in other components:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">(</span><span class="nf">defui</span><span class="w"> </span><span class="o">^</span><span class="no">:once</span><span class="w"> </span><span class="n">Foo</span><span class="w">
      </span><span class="n">static</span><span class="w"> </span><span class="n">om/IQuery</span><span class="w">
      </span><span class="p">(</span><span class="nf">query</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
        </span><span class="p">[</span><span class="no">:client/foo</span><span class="p">])</span><span class="w">
      </span><span class="n">Object</span><span class="w">
      </span><span class="p">(</span><span class="nf">render</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nf">html</span><span class="w"> </span><span class="p">[</span><span class="no">:div</span><span class="w"> </span><span class="s">"in foo"</span><span class="p">])))</span><span class="w">

    </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">foo-cmp</span><span class="w"> </span><span class="p">(</span><span class="nf">make-cmp</span><span class="w"> </span><span class="n">Foo</span><span class="p">))</span><span class="w"> </span><span class="c1">;;instead of (def foo (om/factory Foo))</span><span class="w">
</span></code></pre>
<blockquote>
<p>make-cmp:
  Returns a fn[parent-cmp props-or-kw &amp; computed-arg] that when called will
  create a React element. Options can be map with :validator, :keyfn
  and :instrument? keys. If props-or-kw is a keyword its value will be retrieved
  from the parent-cmp props. Any reload-key from the parent-cmp will be added to
  the computed props of this cmp. This will only happen in development.</p>
</blockquote>

<p>So call this foo function with the <code>this</code> of the parent component and the
key you set the query of Foo to:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">(</span><span class="nf">defui</span><span class="w"> </span><span class="o">^</span><span class="no">:once</span><span class="w"> </span><span class="n">RootQbucketList</span><span class="w">
      </span><span class="n">static</span><span class="w"> </span><span class="n">om/IQuery</span><span class="w">
      </span><span class="p">(</span><span class="nf">query</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
        </span><span class="p">{</span><span class="no">:foo</span><span class="w"> </span><span class="p">(</span><span class="nf">om/get-query</span><span class="w"> </span><span class="n">Foo</span><span class="p">)})</span><span class="w">
     </span><span class="p">(</span><span class="nf">render</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">props</span><span class="w"> </span><span class="n">computed</span><span class="w"> </span><span class="n">state</span><span class="p">]}</span><span class="w"> </span><span class="p">(</span><span class="nf">om/data</span><span class="w"> </span><span class="n">this</span><span class="p">)]</span><span class="w">
         </span><span class="p">(</span><span class="nf">foo-cmp</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="no">:foo</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">computed</span><span class="w"> </span><span class="no">:some-key</span><span class="w"> </span><span class="n">some-value</span><span class="p">)))))</span><span class="w">
</span></code></pre>
<p>It&rsquo;s first of all a bit more straightforward get a handle on the props, computed
and state values. But also the proper value is passed on to foo-cmp, less error
prone. Last benefit is that if you defined a :client/reload-key in your root
component&rsquo;s query and you make sure that the value of that key is modified on
every reload in dev mode (as a result of modifying source code) then the gui is
updated as a whole (since the reload-key is passed on to child components in the
computed value by aum).</p>

<p><a id="orgb5d4105"></a></p>
<h2 id='garbage-collection'>Garbage collection</h2>
<p>There is currently no garbage collecting implemented. As with any garbage
collection the criteria for this are rather app and platform specific. But in
principle you will only have to delete data from app state. If the ui gets in a
state where it requires that data it will just be added to any remote query
again.</p>

<p>A history of all app-state is kept, this is limited to 100 by default. This
could be reduced. On page change you could just wipe any idents referred to
by that page.</p>

<p><a id="orgcb308dd"></a></p>
<h2 id='internationalization'>Internationalization</h2>
<p>There is a common.i18n.cljc <code>TODO-aum</code> namespace which provides a translate
function which takes the current locale as passed into components as a computed
property and a key to translate.</p>

<p><a id="org1b1bfc6"></a></p>
<h2 id='pre-merge-hooks'>Pre-merge hooks</h2>
<p>These hooks allow you to take action before <span class="underline">any</span> value gets merged with
frontend app-state, including responses to read queries.</p>

<p><a id="org233ea68"></a></p>
<h2 id='merging-pushed-data'>Merging pushed data</h2>
<p>Backend can use websockets for resolving queries from the frontend, but this
means it&rsquo;s also possible to &rsquo;push&rsquo; data. The frontend can  respond to this and
merge this as any regular response to a query. This is useful to keep instances
of the app in sync, but also to show notifications, or to push a response of a
query in an async manner. It can be sent to the frontend if and whenever the
required data is available.</p>

<p><a id="org5d63707"></a></p>
<h2 id='generic-undo-redo-revert'>Generic undo/redo/revert.</h2>
<p>Every mutation on a record adjust some metadata on the record that enables
undo/redo/revert for that record. This also includes any data joined to that
record, they will also get undone/redone/reverted.</p>

<p><a id="orgc68169c"></a></p>
<h1 id='backend-parser'>Backend parser</h1>
<p><a id="org0a88b69"></a></p>
<h2 id='table-aliases'>Table aliases</h2>
<p>TODO-doc</p>

<p><a id="org39403a9"></a></p>
<h2 id='virtual-tables'>Virtual tables</h2>
<p>TODO-doc</p>

<p><a id="org0b6510b"></a></p>
<h2 id='have-backend-return-calculated-data'>Have backend return calculated data</h2>
<p>There are three ways to do this:</p>

<p><a id="orgd6e7f9e"></a></p>
<h3 id='calculate-something-over-a-sub-query'>Calculate something over a (sub)query</h3>
<p>Sometimes you want something to be calculated over a query and return not only
the rows themselves, but also the extra data, such as total count. This is
particularly tricky if you want to calculate something over a join. You want
the joined rows, but also some more data over that particular subset of rows
(joined as they are to the parent record).</p>

<p>To do this add a :with-meta param key to the params of the query. Set this to a
single keyword or map or a vector of them. If it&rsquo;s a map it should have at
least a key :type, but you can then add more params for the calculation if you
want.</p>

<p>You can then extend the calc-meta-data multimethod from
aum.parser.calc-meta-data in the backend which is dispatched on those
:with-meta keys, or the :type value if it&rsquo;s a map. The method is called after
the original sql query has been done. The sql-fn called, its args and
calc-params as passed fromt the frontend.</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">[{</span><span class="no">:group</span><span class="w"> </span><span class="p">[({</span><span class="no">:user</span><span class="w"> </span><span class="p">[</span><span class="no">:id</span><span class="w"> </span><span class="no">:name</span><span class="p">]}</span><span class="w"> </span><span class="p">{</span><span class="no">:with-meta</span><span class="w"> </span><span class="p">[</span><span class="no">:count</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="no">:calc2</span><span class="w"> </span><span class="no">:some</span><span class="w"> </span><span class="no">:params</span><span class="p">}]})]}]</span><span class="w">
</span></code></pre>
<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">calc-meta-data</span><span class="w"> </span><span class="no">:count</span><span class="w">
      </span><span class="p">[</span><span class="n">env</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">sql-fn</span><span class="w"> </span><span class="n">sql-fn-args</span><span class="w"> </span><span class="n">return-empty-vector?</span><span class="w"> </span><span class="n">join-type</span><span class="w"> </span><span class="n">calculation-params</span><span class="p">]}]</span><span class="w">
      </span><span class="c1">;;Do your calculation here</span><span class="w">
       </span><span class="p">)</span><span class="w">
</span></code></pre>
<p>One thing to take note of is that the return value for this query will be now of
the form:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">{</span><span class="no">:rows</span><span class="w"> </span><span class="p">[[</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"foo"</span><span class="p">]]</span><span class="w"> </span><span class="no">:meta</span><span class="w"> </span><span class="p">{</span><span class="no">:count</span><span class="w"> </span><span class="mi">123</span><span class="p">}}</span><span class="w">
</span></code></pre>
<p>Which means you will have to take this into account when this data arrives at
your component, and/or when you implement the read method for the join with the
:with-meta param.</p>

<p><a id="orge8de2b7"></a></p>
<h3 id='define-a-read-key-in-the-backend'>Define a read key in the backend</h3>
<p>Such as:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">aum/read</span><span class="w"> </span><span class="no">:calc/count</span><span class="w">
      </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="n">parser</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="n">parser-config</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">env</span><span class="p">}</span><span class="w"> </span><span class="n">_</span><span class="w">
       </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">table</span><span class="w"> </span><span class="n">where</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">params</span><span class="p">}]</span><span class="w">
      </span><span class="c1">;;You can use the query to decide on what to calculate perhaps</span><span class="w">
      </span><span class="p">(</span><span class="nf">timbre/info</span><span class="w"> </span><span class="n">query</span><span class="p">)</span><span class="w"> </span><span class="c1">;;=&gt; [:count]</span><span class="w">
      </span><span class="p">{</span><span class="no">:value</span><span class="w"> </span><span class="p">{</span><span class="no">:count</span><span class="w"> </span><span class="p">(</span><span class="nf">count-records</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="n">params</span><span class="p">)}})</span><span class="w">
</span></code></pre>
<p>Then add a query to a component:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">({</span><span class="no">:calc/count</span><span class="w"> </span><span class="p">[</span><span class="no">:count</span><span class="p">]}</span><span class="w"> </span><span class="p">{</span><span class="no">:table</span><span class="w"> </span><span class="no">:user</span><span class="w">
                             </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="no">:id</span><span class="w"> </span><span class="no">:&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">]})</span><span class="w">
</span></code></pre>
<p>Disadvantage of this method is that you can only use this query as a root query
or quasi root query. Also you have to possibly duplicate the params of this query in the
frontend from another query. And this isn&rsquo;t useful for a joined query.</p>

<p><a id="orgec2b587"></a></p>
<h3 id='redirect-a-read-to-a-custom-read'>Redirect a read to a custom-read</h3>
<p>Used search translations. Idea is to set a :custom-read key in the params of a
query. Backend will use the read method as set to the :custom-read key and pass
in the rest of params as well.</p>

<p>Advantage of this is that you can redirect a query for a join to your own read
method. Where you can then return a calculated value, any rows queried for
and/or any other data you like.</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">aum/read</span><span class="w"> </span><span class="no">:count-records</span><span class="w">
      </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">user</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="n">parser</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="n">parser-config</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">env</span><span class="p">}</span><span class="w"> </span><span class="n">_</span><span class="w">
       </span><span class="p">{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">table</span><span class="w"> </span><span class="n">where</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">params</span><span class="p">}]</span><span class="w">
      </span><span class="p">{</span><span class="no">:value</span><span class="w"> </span><span class="p">(</span><span class="nf">count-records</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="n">params</span><span class="p">)})</span><span class="w">
</span></code></pre>
<p>With this query:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="o">'</span><span class="p">({</span><span class="no">:user-count</span><span class="w"> </span><span class="p">[</span><span class="no">:count</span><span class="p">]}</span><span class="w"> </span><span class="p">{</span><span class="no">:custom-read</span><span class="w"> </span><span class="no">:count-records</span><span class="w">
                              </span><span class="no">:table</span><span class="w"> </span><span class="no">:user</span><span class="w">
                              </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="no">:id</span><span class="w"> </span><span class="no">:&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">]})</span><span class="w">
</span></code></pre>
<p><a id="orgda4213e"></a></p>
<h1 id='testing'>Testing</h1>
<p><a id="org8369083"></a></p>
<h2 id='backend-testing'>Backend testing</h2>
<p>TODO-doc:</p>

<p><a id="orge34eb43"></a></p>
<h2 id='frontend-testing'>Frontend testing</h2>
<p><a id="org50abb89"></a></p>
<h3 id='install-3'>Install</h3>
<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    nvm install
    nvm use
    npm install
    npm install -g karma-cli
</code></pre>
<p><a id="org47157fc"></a></p>
<h3 id='test-runner'>Test runner</h3>
<p>Standalone client-side om-next test-runner app to be used with the
alternative test macros that add and remove tests to the lists of tests. Several
ways to display diffs. Rerun test on click. Use snapshots for any test instead
of writing the required result into the test. Helpers to click and compare html
output for acceptance ui tests. Replay/rewind/step through (ui) tests by using
pause macro.</p>

<p><a id="orgbf2e5fb"></a></p>
<h3 id='snapshots'>Snapshots</h3>
<p>There are facilities to create a test by putting it together step by step and
instead inserting expected results take snapshots and use them instead. This is
particularly handy for testing states of the ui. It&rsquo;s also then possible to step
through the test in the test runner. If any intermediate snapshot fails the test
but (because we updated the code for example) is what we do expect we can update
the snapshot by clicking a button.</p>

<p><a id="org34b0864"></a></p>
<h2 id='run-backend-in-frontend-for-testing-for-example'>Run backend in frontend (for testing for example)</h2>
<p>It is possible to run the whole backend in the frontend where the mysql database
is &rsquo;mocked&rsquo; in the frontend. This is ideal for writing integration tests
covering the whole stack</p>

<p>TODO-doc: add examples and working starter branch
NOTES:
Browser in memory sql options:
<a href="https://github.com/kripken/sql.js">https://github.com/kripken/sql.js</a>
<a href="https://github.com/agershun/alasql/wiki/Getting%20started">https://github.com/agershun/alasql/wiki/Getting%20started</a></p>

<p><a id="orgd901d70"></a></p>
<h2 id='whole-stack-testing'>Whole stack testing</h2>
<p>By combining test runner, snapshot testing and running backend in frontend it&rsquo;s
possible to do whole stack testing.</p>

<p><a id="org9e8843f"></a></p>
<h2 id='fixtures-per-test'>Fixtures per test</h2>
<p>It&rsquo;s possible to set up a context for one more tests to run in. Inside the
macro call `in-context` you&rsquo;ll have access to tu/*env* which will be set
properly according to the context you&rsquo;re in. The <strong>env</strong> has db-conn which you
can use directly or you can use the a parser or bilby.database.query/sql and
pass in <strong>env</strong>. For your convenience two more dynamic variables, tu/*parser*
and tu/*state* are bound while &rsquo;in-context&rsquo; using the parser-config and
db-config passed in when creating a context using tu/make-context.</p>

<p>(require
     &#39;[bilby.app-config :refer [config]]
     &#39;[clojure.test :refer [deftest is]]
     &#39;[bilby.test.util :as tu :refer [debug-tests unload-all-tests unmap-all-interns in-context truthy?
                                      make-context query]]
     )</p>

<p>;;This will create just the one table, foos, with just one row.
    (def fixtures {:foos {:rows [{:id 1 :title &quot;bar&quot;}]
                          :options {:id-primary-key? true}
                          :schema {:id :int :title :text
                                   :updated-at :date-time :created-at :date-time}
                          }})</p>

<p>(def my-db-config
      {:root true
       ;;by default you can refer to a table by its singular name (the end s is
       ;;removed from the table-name).
       ;; :table-name :foo :columns
       (keys (get-in fixtures [:foos :schema]))
       ;; :joins {:bar {:t1-foreign-key :bla-id}}
       :read {:role {&quot;super-admin&quot; {:blacklist []}}}
       ;;NOTE: For update, create, delete mutations you&#39;ll might have to create the
       ;;appropriate validations as well.
       :update {:role {&quot;super-admin&quot; {:blacklist [:id :updated-at :created-at :creator-id]}}}
       :create {:role {&quot;super-admin&quot; {:blacklist [:id :updated-at :created-at]}}}}
      )</p>

<p>(def context-foo
      (make-context
       {:db-config {:foo my-db-config}
        ;;Or use config from your app:
        ;;:db-config (select-keys database.config/db-config [:user])
        :parser-config (merge (config) {:allow-root true :print-exceptions true
                                        :sql-log true :query-log true
                                        :event-store-disabled true})
        :fixtures fixtures}))</p>

<p>(def user {:id 1 :some-user &quot;a-user&quot; :role &quot;super-admin&quot; :group-id 10 :subgroup-ids [-1]})</p>

<p>(in-context context-foo
      (tu/<em>parser</em> (assoc tu/<em>env</em>
                          :user user)
                   [{:foo [:id]}]))</p>

<p><a id="orgebb6995"></a></p>
<h1 id='debugging'>Debugging</h1>
<p><a id="org07f3f03"></a></p>
<h2 id='dev-cards'>Dev-cards</h2>
<p>Switch to dev cards page from app itself. TODO-doc TODO-aum</p>

<p><a id="org9513e26"></a></p>
<h2 id='frontend-om-inspector'>Frontend om inspector</h2>
<p>Search, filter and drill into app and om state.</p>

<p><a id="orge9f0987"></a></p>
<h2 id='it-rsquo-s-possible-to-set-some-flags-in-local-storage-to-get-some-output-in-console-etc'>It&rsquo;s possible to set some flags in local storage to get some output in console etc:</h2>
<p>Set log level:</p>

<p>:timbre-level :info</p>

<p>Click on AUM logo and some debug buttons will show up:</p>

<p>:debug-drawer true</p>

<p>Show what query is sent and what is returned:</p>

<p>:send true</p>

<p><a id="org81f297e"></a></p>
<h2 id='in-boot-scripts-there-rsquo-s-tail-boot-to-inspect-logstash-output'>In boot-scripts there&rsquo;s tail.boot to inspect logstash output:</h2>
<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    boot boot-scripts/tail.boot -h

    Options:
      -h, --help        Print this <span class="nb">help </span>info.
      -f, --follow      follow
      -s, --start VAL   VAL sets start <span class="o">(</span>line number or <span class="nb">time</span> <span class="o">(</span>hh:mm<span class="o">)</span> such as <span class="s2">"11:10"</span><span class="o">)</span>.
      -n, --length VAL  VAL sets number of lines or length of <span class="nb">time </span>such as <span class="s2">"10h"</span>, <span class="s2">"5m"</span> <span class="s2">"50s"</span> If start is given <span class="k">then </span>last so many lines or within last so much time.
      -t, --http-log    print http output lines
      -i, --timestamp   print timestamps
      -r, --regex VAL   VAL sets regex to filter lines.
      -l, --level VAL   VAL sets level to filter such as info or error.
</code></pre>
<p><a id="org24eb277"></a></p>
<h2 id='trying-queries'>Trying queries</h2>
<p>In the dev source folder there are namespaces to try out various queries:</p>

<ol>
<li><p>try-om-query</p>

<p>You can call the backend parser with any om-next query. These are resolved
against the database as defined in app.config and using database.config as
defined for the whole app.</p>

<p>There is a second version where you can build your own parser environment and
your own parser with that again.</p></li>
<li><p>Try sql query</p>

<p>To try out any sql query. Make sure to define process-params, validate-sql-fn
and process-result methods, and the equivalent sql fun in build-sql if you want
it to be used in mock mode or tests.</p></li>
<li><p>Try/test frontend parser.</p>

<p>Frontend parser is a cljc file so you can eval this in a clojure repl. You can
test here what the parser returns for queries for the nil and various remote
targets, which is much harder to test/inspect if you have to use the ui to pass
queries to the parser.</p></li>
</ol>

<p><a id="orgd0f99c0"></a></p>
<h1 id='how-to'>How to</h1>
<p><a id="org17fa8d7"></a></p>
<h2 id='add-npm-modules'>Add npm modules</h2>
<ul>
<li>  Add to package.json</li>
<li>  Import package in index.js, set a global to imports</li>
<li>  Create index.bundle.js by running npx webpack</li>
<li>  Create externs file or add externs to foreign-libs.externs.ext.js</li>
<li>  Edit resources/revolt.edn (and/or main.cljs.edn for figwheel):</li>
<li>  Add any new externs file to the externs keys</li>
<li>  Add entries for the exported packages to foreign-libs under the</li>
<li>  foreign-libs/index.bundle.js entry:</li>
<li>  -&gt; The global created in index.js should be added to the global-exports subkey
where the js global var name can be referred to by a clojure symbol ns</li>
<li>  -&gt; Add that symbol ns to to the provides key as a string.</li>
</ul>

<p>Analyze size of webpack bundle:</p>

<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    npx webpack --config webpack.prod.js --json &gt; stats.json
</code></pre>
<p>Upload stat.json to <a href="https://chrisbateman.github.io/webpack-visualizer/">https://chrisbateman.github.io/webpack-visualizer/</a></p>

<p>Or:</p>

<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    bin/analyze-webpackold-app-readme
</code></pre>
<p><a id="org0ffbfb1"></a></p>
<h2 id='querying-other-sources-than-a-mysql-database'>Querying other sources than a mysql database</h2>
<p><a id="org8ad8d59"></a></p>
<h3 id='using-more-than-one-remote-in-the-frontend'>Using more than one remote in the frontend</h3>
<p>In <code>pagora.aum.frontend.reconciler.start</code> this function is defined:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-aum-remote</span><span class="w"> </span><span class="p">[</span><span class="n">app-config</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">query</span><span class="w"> </span><span class="n">response-cb</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">chsk-send!</span><span class="w"> </span><span class="p">(</span><span class="nf">websocket/get-chsk-send!-fn</span><span class="w"> </span><span class="n">app-config</span><span class="p">)]</span><span class="w">
          </span><span class="p">(</span><span class="nf">chsk-send!</span><span class="w"> </span><span class="p">[</span><span class="no">:aum/query</span><span class="w"> </span><span class="n">query</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="no">:websocket-timeout</span><span class="w"> </span><span class="n">app-config</span><span class="w"> </span><span class="mi">8000</span><span class="p">)</span><span class="w">
                      </span><span class="n">response-cb</span><span class="p">))))</span><span class="w">
</span></code></pre>
<p>You can add remotes like this:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">{</span><span class="no">:my-remote</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">app-config</span><span class="p">]</span><span class="w">
                  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">query</span><span class="w"> </span><span class="n">response-cb</span><span class="p">]</span><span class="w">
                    </span><span class="c1">;;Call on the network with the query, call response-cb when response is received.</span><span class="w">
                    </span><span class="p">))}</span><span class="w">
</span></code></pre>
<p>Add this map to app config under the :remotes key.</p>

<p>TODO-doc: add examples to starter app and document here</p>

<p><a id="orgcafbc91"></a></p>
<h3 id='returning-data-fetched-from-another-source-asynchronously'>Returning data fetched from another source asynchronously</h3>
<p>TODO-doc: add examples to starter app and document here
If a backend query can&rsquo;t be resolved and returned synchronously it&rsquo;s possible to
push the result to the frontend when it&rsquo;s available.</p>

<p><a id="org9161b68"></a></p>
<h2 id='optimize-frontend'>Optimize frontend</h2>
<p><a id="orga792069"></a></p>
<h3 id='pathopt'>pathopt</h3>
<p><a href="https://awkay.github.io/om-tutorial/#!/om_tutorial.I_Path_Optimization">https://awkay.github.io/om-tutorial/#!/om_tutorial.I_Path_Optimization</a></p>

<p>Path Optimization</p>

<p>As your UI grows you may see warnings in the Javascript Console about slowness.
If you do, you can leverage path optimization to minimize the amount of work the
parser has to do in order to update a sub-portion of the UI.</p>

<p>If you pass :pathopt true to the reconciler, then when re-rendering a component
that has an Ident Om will attempt to run the query starting from that component
(using it&rsquo;s Ident as the root of the query). If your parser returns a result, it
will use it. If your parser returns nil then it will focus the root query to
that component and run it from root.</p>

<p>When it attempts this kind of read it will call your read function with
:query-root set to the ident of the component that is needing re-render, and you
will need to follow the query down from there. Fortunately, db-&gt;tree still works
for the default database format with a little care.</p>

<p>So om-next calls the parser, but the query will be a (focussed on the cmp) query
against the root of app-data. If you set pathopt to true and a cmp has an ident
and a query it will call the parser with the :query-root key of env to the
ident, and query to the query of the cmp, so the parser can work a bit faster.
Which I do in my parser read* fn</p>

<p><a id="org39f2993"></a></p>
<h2 id='start-app-with-different-ports-and-db'>Start app with different ports and db:</h2>
<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    <span class="nv">DB_NAME</span><span class="o">=</span>my_db <span class="nv">SERVER_PORT</span><span class="o">=</span>9080 <span class="nv">NREPL_PORT</span><span class="o">=</span>38401 bin/dev-backend
</code></pre>
<p><a id="orgf52ebd9"></a></p>
<h2 id='throw-catch-exceptions'>throw catch exceptions</h2>
<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">(</span><span class="nf">try</span><span class="w"> </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="s">"ex-info msg string"</span><span class="w"> </span><span class="p">{</span><span class="no">:type</span><span class="w"> </span><span class="no">:my-exception</span><span class="w"> </span><span class="no">:bla</span><span class="w"> </span><span class="no">:foo</span><span class="p">}))</span><span class="w">
        </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="o">#</span><span class="n">?</span><span class="p">(</span><span class="no">:clj</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="no">:cljs</span><span class="w"> </span><span class="no">:default</span><span class="p">)</span><span class="w"> </span><span class="n">e</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">msg</span><span class="w"> </span><span class="p">(</span><span class="nf">.getMessage</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
                </span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-data</span><span class="w"> </span><span class="n">e</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="nf">info</span><span class="w"> </span><span class="s">"Msg:"</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w">
            </span><span class="p">(</span><span class="nf">info</span><span class="w"> </span><span class="s">"Data:"</span><span class="w"> </span><span class="n">data</span><span class="p">))))</span><span class="w">
</span></code></pre>
<p><a id="orge807e2c"></a></p>
<h1 id='good-to-know'>Good to know</h1>
<p><a id="orgc19a199"></a></p>
<h2 id='function-and-method-signatures'>Function and method signatures</h2>
<p><a id="orgbb0c359"></a></p>
<h3 id='read-and-mutate-env-key-params-todo-doc-update-for-aum'>read and mutate: [env key params] TODO-doc: update for aum</h3>
<p>TODO-doc: update!!!
The read function you write:</p>

<p>Will receive three arguments:
An environment containing:
:parser:   The query parser
:state:    The application state (atom)
:query:    if the query had one E.g. {:people [:user/name]} has :query [:user/name]
A key whose form may vary based on the grammar form used (e.g. :user/name).
Parameters (which are nil if not supplied in the query)
Must return a value that has the shape implied by the grammar element being read.</p>

<p>The signature of a read function is:</p>

<p>(read [env dispatch-key params])</p>

<p>where the env contains the state of your application, a reference to your parser (so you can call it recursively, if you wish), a query root marker, an AST node describing the exact details of the element&rsquo;s meaning, a path, and anything else you want to put in there if you call the parser recursively.</p>

<p>The parse will create the output map.
(keys env) in mutation=&gt;
(:query-root :path :pathopt :reconciler :ast :state :component :parser :logger :shared :target)
(keys env) in read =&gt;
(:query-root :path :pathopt :ast :state :parser :logger :shared :target :query)</p>

<p><a id="org7745bc6"></a></p>
<h2 id='syncing-of-front-and-backend'>Syncing of front and backend</h2>
<p>All records have as their meta data something like this:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">{</span><span class="no">:record</span><span class="w"> </span><span class="p">{</span><span class="no">:id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:type</span><span class="w"> </span><span class="no">:foo</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"bar"</span><span class="p">}</span><span class="w"> </span><span class="c1">;;record as it came from the servr</span><span class="w">
     </span><span class="no">:uuids</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="c1">;;history keeping</span><span class="w">
     </span><span class="no">:prev-uuid</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w">
</span></code></pre>
<p>The meta record map is nil unless something has been modified in the record
itself. The various uuid keys are used for undo/redo functionality. They are
references to a particular state in the history of states for the app as kept by
om-next.</p>

<p>Reverting a record is as easy as replacing with its meta record. Calculating
what has changed to a record for purposes of sending modification to the backend
is doing a diff. And to decide whether its &rsquo;dirty&rsquo; aum in essence just
does a comparison.</p>

<p>It&rsquo;s possible for example to reset just the one prop of a record as a result of
clicking a &rsquo;reset&rsquo; button in the component for that field. The original value
can always be fetched from the meta record.</p>

<p><a id="orgcf5490a"></a></p>
<h1 id='modules-wip-code-exists-but-needs-to-be-added'>Modules (wip, code exists but needs to be added)</h1>
<p><a id="orge3357f7"></a></p>
<h2 id='database-migration'>Database migration</h2>
<p>Viable database migration libraries:</p>

<ul>
<li>  <a href="https://github.com/weavejester/ragtime">https://github.com/weavejester/ragtime</a></li>
<li>  <a href="https://github.com/yogthos/migratus">https://github.com/yogthos/migratus</a></li>
<li>  <a href="https://github.com/budu/lobos">https://github.com/budu/lobos</a></li>
<li>  <a href="https://github.com/juxt/joplin">https://github.com/juxt/joplin</a> (built on top of ragtime)</li>
</ul>

<p>There&rsquo;s examples in the starter app that show the use of <a href="https://github.com/juxt/joplin">joplin</a>.</p>

<p>It&rsquo;s nice not to have to write sql strings so
<a href="https://github.com/stch-library/sql">https://github.com/stch-library/sql</a> dsl is used:</p>

<blockquote>
<p>A DSL in Clojure for SQL query, DML, and DDL. Supports a majority of MySQL&rsquo;s statements.</p>
</blockquote>

<p>Both these libs are included with aum.</p>

<p>See the src/joplin directory in the aum starter app repo for examples of config, migrations and seeds.</p>

<p>Require joplin aliases:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">    </span><span class="p">[</span><span class="n">pagora.aum.modules.db-migration.joplin.alias</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">joplin-do</span><span class="p">]]</span><span class="w">
</span></code></pre>
<p>And execute any of the following in the repl:</p>

<div class="center-column"></div>
<pre class="highlight clojure tab-clojure"><code><span class="w">      </span><span class="p">(</span><span class="nf">joplin-do</span><span class="w"> </span><span class="no">:migrate</span><span class="w"> </span><span class="p">{</span><span class="no">:config</span><span class="w"> </span><span class="s">"joplin.edn"</span><span class="w"> </span><span class="no">:env</span><span class="w"> </span><span class="no">:dev</span><span class="p">})</span><span class="w">
      </span><span class="p">(</span><span class="nf">joplin-do</span><span class="w"> </span><span class="no">:pending</span><span class="w"> </span><span class="p">{</span><span class="no">:config</span><span class="w"> </span><span class="s">"joplin.edn"</span><span class="w"> </span><span class="no">:env</span><span class="w"> </span><span class="no">:dev</span><span class="w"> </span><span class="no">:db</span><span class="w"> </span><span class="no">:aum-minimal</span><span class="p">})</span><span class="w">
      </span><span class="p">(</span><span class="nf">joplin-do</span><span class="w"> </span><span class="no">:rollback-n</span><span class="w"> </span><span class="p">{</span><span class="no">:config</span><span class="w"> </span><span class="s">"joplin.edn"</span><span class="w"> </span><span class="no">:env</span><span class="w"> </span><span class="no">:dev</span><span class="w"> </span><span class="no">:db</span><span class="w"> </span><span class="no">:aum-dev</span><span class="w"> </span><span class="no">:num</span><span class="w"> </span><span class="s">"1"</span><span class="p">})</span><span class="w">
      </span><span class="p">(</span><span class="nf">joplin-do</span><span class="w"> </span><span class="no">:seed</span><span class="w"> </span><span class="p">{</span><span class="no">:config</span><span class="w"> </span><span class="s">"joplin.edn"</span><span class="w"> </span><span class="no">:env</span><span class="w"> </span><span class="no">:dev</span><span class="w"> </span><span class="no">:db</span><span class="w"> </span><span class="no">:aum-dev</span><span class="p">}</span><span class="w"> </span><span class="p">[</span><span class="s">"seed1"</span><span class="p">])</span><span class="w">
      </span><span class="p">(</span><span class="nf">joplin-do</span><span class="w"> </span><span class="no">:rebuild</span><span class="w"> </span><span class="p">{</span><span class="no">:config</span><span class="w"> </span><span class="s">"joplin.edn"</span><span class="w"> </span><span class="no">:env</span><span class="w"> </span><span class="no">:dev</span><span class="w"> </span><span class="no">:db</span><span class="w"> </span><span class="no">:aum-minimal</span><span class="p">}</span><span class="w"> </span><span class="p">[</span><span class="s">"seed1"</span><span class="p">])</span><span class="w"> </span><span class="c1">;;drops and creates db, applies migrations and seed</span><span class="w">
      </span><span class="p">(</span><span class="nf">joplin-do</span><span class="w"> </span><span class="no">:reset</span><span class="w"> </span><span class="p">{</span><span class="no">:config</span><span class="w"> </span><span class="s">"joplin.edn"</span><span class="w"> </span><span class="no">:env</span><span class="w"> </span><span class="no">:dev</span><span class="w"> </span><span class="no">:db</span><span class="w"> </span><span class="no">:aum-minimal</span><span class="p">})</span><span class="w"> </span><span class="c1">;;rolls back all migrations, applies them again and runs any seed</span><span class="w">
      </span><span class="p">(</span><span class="nf">joplin-do</span><span class="w"> </span><span class="no">:create</span><span class="w"> </span><span class="p">{</span><span class="no">:config</span><span class="w"> </span><span class="s">"joplin.edn"</span><span class="w"> </span><span class="no">:db</span><span class="w"> </span><span class="no">:aum-minimal</span><span class="w"> </span><span class="no">:id</span><span class="w"> </span><span class="s">"my-new-migration"</span><span class="p">})</span><span class="w">
</span></code></pre>
<p>Note the difference between reset and rebuild. Reset also doesn&rsquo;t allow setting
any seed fn args.</p>

<p>Alternatively use the terminal to manage migrations etc:</p>

<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>    clj -A:joplin migrate -d aum-minimal
    clj -A:joplin pending -d aum-minimal
    clj -A:joplin rollback-n -d aum-minimal -n 1
    clj -A:joplin seed -d aum-minimal seed1
    clj -A:joplin create -d aum-minimal -i my-new-migration
    clj -A:joplin reset -d aum-minimal seed1
    clj -A:joplin rebuild -d aum-minimal seed1
    clj -A:joplin -h
</code></pre>
<p>Last invocation will get you:</p>

<div class="center-column"></div>
<pre class="highlight shell tab-shell"><code>      -a, --action ACTION                migrate, seed, rollback, reset, pending or create
      -c, --config CONFIG    joplin.edn  EDN resource with joplin configuration.
      -e, --env ENVIRONMENT  dev         dev, staging, prod or <span class="nb">test</span>
      -d, --db DATABASE                  database to <span class="k">do </span>migration on
      -n, --num NUM          1           number of migrations to rollback
      -i, --id ID                        name of migration to create
      -h, --help
</code></pre>
<p><a id="org0cd69f1"></a></p>
<h2 id='files-download'>Files download</h2>
<p><a id="org94b5d25"></a></p>
<h2 id='pdfkit'>Pdfkit</h2>
<p>A wrapper for <a href="https://pdfkit.org/">https://pdfkit.org/</a>:</p>

<blockquote>
<p>A JavaScript PDF generation library for Node and the browser.</p>
</blockquote>

<p>Copied from <a href="https://github.com/whamtet/cljs-pdfkit">https://github.com/whamtet/cljs-pdfkit</a>. For some reason I couldn&rsquo;t
get it to work as a cljs dependency.</p>

<p><a id="org928962c"></a></p>
<h2 id='icons'>Icons</h2>
<p>Icon classes like icon-cached, icon-undo, icon-redo etc are defined in
icomoon-icons.css in the src/styling/scss directory which is a soft link to
icomoon/style.css</p>

<p>This is a generated file by the chrome app:
<a href="https://chrome.google.com/webstore/detail/icomoon/kppingdhhalimbaehfmhldppemnmlcjd">https://chrome.google.com/webstore/detail/icomoon/kppingdhhalimbaehfmhldppemnmlcjd</a></p>

<p>Click &ldquo;Import icons&rdquo; and select [aum-starter-app-dir]/icomoon/selection.json</p>

<p>This adds currently used icons in the app to the selectable icons.</p>

<p>Select any extra icons you want and then click &ldquo;Generate Font&rdquo; (right below),
then &ldquo;Download&rdquo;. It exports a zip file which includes currently used icons in
app, plus any other you&rsquo;ve addded..</p>

<p>Replace the icomoon dir with the unzipped exported zip file.</p>

<p>In resources/app/fonts there are soft links to the fonts in icomoon/fonts.</p>

<p><a id="org6d355eb"></a></p>
<h2 id='auth'>Auth</h2>
<p><a id="org0a408be"></a></p>
<h3 id='login-logout'>login/logout</h3>
<p>There&rsquo;s login/logout methods in app/security.cljc. Disabled in production.</p>

<p>Aum comes with login and logout fns for both front and backend. However in
production this is disabled. The remember token is used to authenticate the
session. One complication is that because how sente/websockets work is that to
renew the session and any attached remember token the connection has to be
renewed.</p>

<p><a id="org9a4b233"></a></p>
<h3 id='subscriptions'>subscriptions</h3>
<p><a id="org508abfe"></a></p>
<h3 id='wip-accounts-users-and-roles'>WIP accounts, users and roles</h3>
<p><a id="org16c2970"></a></p>
<h3 id='process-user-and-calc-role-snippets'>Process-user and calc-role snippets</h3>
<p>;; (defn superaccount? [db-conn account-id]
;;   (-&gt; (q/get-cols-from-table db-conn {:cols [&ldquo;superaccount&rdquo; &ldquo;id&rdquo; &ldquo;name&rdquo;] :table &ldquo;accounts&rdquo;
;;                                       :where-clause [&ldquo;where id = ?&rdquo; account-id]})
;;       first
;;       :superaccount))</p>

<p>;; (defn calc-role
;;   &ldquo;Calculates role depending on account-id and any listing in admins table,&rdquo;
;;   [{:keys [db-conn config] :as env} {:keys [account-id ] :as user}]
;;   (when (some? user)
;;     (cond
;;       (= account-id (:pagora-account-id config)) &ldquo;super-admin&rdquo;
;;       :else (let [admin-account-ids (-&gt;&gt; (q/get-cols-from-table db-conn {:cols [&ldquo;account<sub>id</sub>&rdquo;] :table &ldquo;admins&rdquo;
;;                                                                          :where-clause [&ldquo;where user<sub>id</sub> = ?&rdquo; (:id user)]})
;;                                        (map :account<sub>id</sub>))
;;                   account-admin? (cu/includes? admin-account-ids account-id)]
;;               (cond
;;                 account-admin? (if (superaccount? db-conn account-id) &ldquo;superaccount-admin&rdquo; &ldquo;account-admin&rdquo;)
;;                 :else &ldquo;user&rdquo;
;;                 )
;;               ))))</p>

<p>;; A much better option is a total separation of Users and Accounts. A user can
;; have several accounts (usually with a default one selected), and they can use
;; a single login to access each, and each account may have multiple users
;; associated with it.
;;So we need:
;;accounts<sub>users</sub> table</p>

<p>;; So account-id is not which account a user belongs to but which account the
;; user wants to access.</p>

<p>;; After that a user has a role within that account. Such as account-admin. If
;; the account is a super account (so administering more than just its own
;; account) then if the user has the account-admin role it might also have the
;; superaccount-admin</p>

<p>;;So we&rsquo;d need a accounts-users-roles table.</p>

<p>;; (defmethod process-user &ldquo;superaccount-admin&rdquo;
;;   [{:keys [db-conn] :as env} user]
;;   (let [role (calc-role env user)
;;         subaccount-ids (-&gt;&gt; (q/get-cols-from-table db-conn {:cols [&ldquo;id&rdquo;] :table &ldquo;account&rdquo;
;;                                                             :where-clause [&ldquo;where account<sub>id</sub> = ?&rdquo; (:account-id user)]})
;;                          (mapv :id))
;;         ;;Can&rsquo;t be empty else sql query crashes (used in scope in database config)
;;         subaccount-ids (if (seq subaccount-ids) subaccount-ids [-1])] ;; but IN (-1) always results in false, same result.
;;     (assoc user
;;            :role role
;;            :subaccount-ids subaccount-ids)))</p>

<p><a id="orga3cc35a"></a></p>
<h2 id='events'>Events</h2>
<p>Also see script in modules/events/experimental</p>

<p><a id="orgcd094d6"></a></p>
<h2 id='af8207aece'>----</h2>
<p><a id="orgf0d4a58"></a></p>
<h2 id='generic-save-records'>Generic save records</h2>
<p>When you have a page with records including their joins recursively you might
want to save the whole lot in one hit. Aum calculates the actual
modifications, and only sends what&rsquo;s changed to the backend. The backend then
will save these records in the right order, taking into account newly created
records and any dependencies on them and will if anything went wrong with
updating a record return this info per record. It garantuees to leave the db in
a consistent and validated state and returns enough information so the frontend
can correct any optimistically updates to its own app state and make sure it&rsquo;s
stays in sync with the backend.</p>

<p><a id="org13c0a41"></a></p>
<h2 id='frontend-validation-of-form-values'>Frontend validation of form values</h2>
<p>When doing a save of a record on a particular page aum looks in the app
config for that page a validation function for every prop of the record. If any
prop is not &rsquo;valid&rsquo; it&rsquo;s added to the client/invalidated-fields map of the state
for that page (under the table key for that record). This can be queried for in
the relevant component and used to set any ui flags and/or messages for that
field.</p>

<p>TODO:
Currently this happens when a record gets saved, but it&rsquo;s possible to add a
mutation that does this on demand, for instance on onBlur..
On save of eg a dossier type:
(bu/get-key-in-page-state @state :dossier-type :validate)
invalidated-fields (bu/calc-invalidations dossier-type validate)</p>

<p>(if (seq invalidated-fields)
  (bu/set-key-in-page-state state :dossier-type :invalidated-fields invalidated-fields))</p>

<p>So on save you fetch validate map for the relevant record type
You give the record and the validate map to calc-invalidations</p>

<p>For every key in record calc-invalidations calls the validated? fn of the value
map of the same key in the validate map and sets the [:invalidated? :prop] key in the
validate map to true and returns it.</p>

<p>So in page-state:</p>

<p>{:route/dossier-types {:table {:dossier-type {:validate {:name validate-name-map
                                                             :some-other-prop validate-some-other-prop}
                                                   :invalidated-fields {:name {:invalidated? {} :message &quot;&quot;}
    }}}}</p>

<p>You then set a key called :invalidated-fields in page state to that validate
map. Which you can pick up in your components and use it to modify the ui if
needed (show in red, show error message etc)</p>

<p><a id="org5958414"></a></p>
<h2 id='frontend-paging'>Frontend paging</h2>
<p><a id="orgb7d310b"></a></p>
<h2 id='frontend-routing-and-url-state'>Frontend routing and url state</h2>
<p><a id="orgf0120a8"></a></p>
<h2 id='internationalization-2'>Internationalization</h2>
<p><a id="orgfd632c3"></a></p>
<h3 id='there-is-a-common-i18n-cljc-namespace-which-provides-the-translate-fn-which'>There is a common.i18n.cljc namespace which provides the translate fn which</h3>
<p>takes the current locale and a key.</p>

<p><a id="org342a1b2"></a></p>
<h3 id='use-params-in-translation-keys-so-interpolation'>use params in translation keys, so interpolation</h3>
<p><a id="orgab73bda"></a></p>
<h3 id='load-translations-zipped'>load translations zipped!!!???!!!!</h3>
<p><a id="org7f94a0b"></a></p>
<h2 id='integrations'>Integrations</h2>
<p><a id="org6636654"></a></p>
<h3 id='bugsnag-logging-newrelic-etc'>Bugsnag, logging, newrelic etc</h3>
<p><a id="orgb6070af"></a></p>
<h3 id='bugsnag'>bugsnag</h3>
<ul>
<li>  Load bugsnag api keys from gitignored .env file in update-html-string</li>
</ul>

<p><a id="org4589a23"></a></p>
<h2 id='files-upload'>Files upload</h2>
<p><a id="org4aafd43"></a></p>
<h2 id='frontend-testrunner'>Frontend testrunner</h2>
<p><a id="org2b27cf5"></a></p>
<h2 id='frontend-data-inspector'>Frontend data inspector</h2>
<p><a id="org3414ab6"></a></p>
<h2 id='fullstack-mock-and-testing'>Fullstack mock and testing</h2>
<p><a id="org5fdc7d2"></a></p>
<h2 id='frontend-page-macro'>Frontend page macro</h2>
<p>TODO-aum:-
There are some basic fns for this. See app.pages for how to add a page.</p>

<p><a id="orgc0fab13"></a></p>
<h1 id='code-outline'>Code outline</h1>
<p><a id="org57d9355"></a></p>
<h2 id='backend-3'>Backend</h2>
<p>The app uses websockets (library is sente) to communicate with the backend. In
web-server.handler/handler there is a request handler added using
web-server.routes/routes which deals with routes for dashboard, resources for
the admin app itself, but also with a sente-route as defined in
websockets.core/sente-route. This sente route handler forwards any messages to
the multimethod websocket.dispatcher/event-msg-handler. Regular messages from
the frontend are of type :admin/query, dispatched to handle-admin-query. This fn is
the main handler of om-next queries and mutations as sent by the frontend.</p>

<p>For every websocket request first the user is fetched by remember-token as set
on the (websocket) request. This user is added to the env given to the parser
together with the om-next query.</p>

<p>The result of this parser call is then sent to the frontend by the reply-fn as
supplied by sente. Some added complexity stems from the fact that the code can
run in frontend for testing purposes. Also a callback fn is added to the env so
any handler code of queries can send data to the frontend asynchronously</p>

<p>There&rsquo;s login and logout handlers in this namespace, but this is disabled in
production mode.</p>

<p>Parser and parser env is defined in parser.core as a mount.core state. The
actual parser and its env is created in bilby.parser.</p>

<p>The om-next read and mutate multimethods are defined in bilby.parser.read and
bilby.parser.mutate.</p>

<p>The bilby mutate multimethod deals with basic save-record and delete-record.
This uses validation methods as defined in db-config to control access. Further
mutate methods are defined in the app&rsquo;s parser.mutate ns.</p>

<p>There are a few read methods in parser.read, but the bulk of frontend queries is
dealt with in bilby.parser.read ns. This namespace is a generic parser and
interpreter of om-next queries. It tries to resolve this query using the mysql db
as configured in the env.In essence it&rsquo;s a recursive resolver. It uses just a
few predefined, parameterized sql queries defined using the hugsql library
(get-cols-from-table and get-joined-rows). Tables in the database need to be
configured in db-config in the env, otherwise access is denied.</p>

<p>Some features (some controlled by parser-config):</p>

<ul>
<li>  :om-process-roots (boolean)
If a key in a join is not recognized as a db table it is
ignored. So a query like: [{:foo [{:user [:id]}]}] will return for example:
{:foo {:user [{:id 1} {:id 2}]}}. If this om-process-roots is true the query
will fail because it will expect :foo to be a valid db table. This is rather
handy for frontend query building since we can insert multiple &rsquo;placeholder&rsquo;,
or &rsquo;dummy&rsquo; keys before querying for table data.</li>
<li>  :limit-max (number)
Since we can basically query the db (within the constraints as set by
db-config) freely, and from join to join we can end up with a lot of data.
Set to 100 by default, this prevents this from happening to some degree.</li>
<li>  :derive-join-type-from-schema (boolean)
For instance [{:template [{:user [:id]}]}] will look for a table
templates-users to resolve the join.</li>
<li>  normalize (boolean)
Whether to return table data in-lined or in a table/by-id map</li>
<li>  When a table query has params such as {:with-meta :count} the query is
resolved normally, but also all data (query-fn, params etc) is handed over to
a multimethod calc-meta-data. Any data returned from this multimethod is
combined with the result of the query itself in a map like this:
{:rows [..] :meta &#x2026;.}. Frontend will have to take this into account and pry
the relevant data out in the appropriate read methods.</li>
<li>  It&rsquo;s possible to set aliases for tables in db-config. Handy for renaming
tables, having multiple joins to the same table etc.</li>
<li>  It&rsquo;s possible to write your own (read method) resolver for a join by adding :custom-read key
and value to the params of a query.</li>
<li>  In general, the parser tries to do the expected thing, but when there&rsquo;s
ambiguity, or a query is not properly formulated it will throw an error,
caught in the default read method.</li>
</ul>

<p><a id="orga50817a"></a></p>
<h2 id='frontend-3'>Frontend</h2>
<p><a id="org7355ac9"></a></p>
<h3 id='app-core-cljs'>app.core.cljs</h3>
<p>app/core.cljs is where the app is mounted and started.</p>

<p>To get around some cyclical namespace issues we implement a channel, and start a
channel listener. The websocket is started by calling websocket.core/start!.
This forwards any messages to the multimethod
websocket.dispatcher/websocket-msg-handler. What we&rsquo;re mainly interested in is
the :chsk/state and :chsk/recv sente websocket messages. The first one will let
us put a msg on the app channel about websocket status, which can then be
processed by the app. The :chsk/recv we use for picking up any data pushed to
the app from the server.</p>

<p>Once websocket is up and connected we actually mount the app, which starts the
om-next cycle of taking the app state, hydrating the ui with them, responding to
mutations and again reading app-state etc. Any read methods returning a remote
ast will trigger reads on the backend.</p>

<p>Frontend similar to backend tries to resolve om-next queries in a generic way in
bilby.reconciler.parser.read in the current production admin. This is a kind of
kitchen sink read method, and tries to send only queries for properties that are
not yet in the frontend app state. To have conditional backend queries (eg
autocomplete) the mechanism of set-params is used. In the templates branch the
om-next/db-&gt;tree is actually rewritten so it&rsquo;s possible to create read methods
for any key in the query tree, which is much more flexible and easier to
understand. The whole bilby.reconciler.parser.read namespace is thus not needed
anymore.</p>

<p><a id="orga6997cf"></a></p>
<h3 id='basic-structure-of-an-admin-page'>Basic structure of an admin page.</h3>
<p>A standard admin page is very often a basic crud ui. Since this is so standard
it&rsquo;s abstracted somehow by the defcmp macro. It sets up a selectable, scrollable
list of records on the left, with a form on the right. It can be extended to
some degree, but for a more flexible layout and functionality it&rsquo;s better (and
much easier) to just start from scratch (examples are templates and dossier type
admin pages).</p>

<p>First step is in both cases to add your new page to app.pages ns. This should
get you an entry in the pages dropdown. There is a default admin page you can
use as a template and starting point. When building a page the practice is to
build your ui up to some degree, including queries on any components. If data is
not returned from the backend you should use try-om-query.clj in your repl and
test your whole or partial queries that are not working. Most often there is an
error in your query, or the database config is not letting you fetch the data
(yet). In general you should not have to adapt or write any code for the backend
other than updating db-config and writing mutations. Of course there are always
edge cases. However for the ones I&rsquo;ve encountered so far I have been able to
adapt the generic backend parser to accommodate these non standard requests. One
is for example using self joins (use aliases), or returning extra data (use meta
data mechanism), there are a few more as added over the years.</p>

<p>The biggest trick is to write proper read methods. (Or the set-params mechanism
in older bilby-libs versions). In general you always want to return what&rsquo;s in
app-state, but not always trigger a remote query if data is not present in the
frontend, however sometimes you do still. By setting flags and data in app-state
it&rsquo;s possible to steer/control these read methods somewhat based on what&rsquo;s
happening in the ui (this is similar to om-next dynamic queries, but much more
explicit and transparent for the programmer to use). For instance in the
template editor there is a massive recursive query for the whole of the ui. If
sent as is to the backend it would theoretically return every template, category
and question in the db (but backend has some limits set to that in practice).
However initially you only want to load the top templates. And only a subset if
you&rsquo;re paging. Once a user clicks on template, only then do you want to download
any linked categories and questions. And even then perhaps only partial data for
these linked records, such as name, but not any other data. By carefully writing
read methods for these joins and keeping track in app state of what the state of
the page is it&rsquo;s possible to have fine control over what gets actually sent to
the backend as a query.</p>

<p><a id="org3fbfc9b"></a></p>
<h3 id='misc-notes-on-code'>Misc notes on code</h3>
<ol>
<li><p>Update ui on save</p>

<p>Figwheel picks up any changes to namespaces and calls my-after-reload-callback
in user.cljs. All that does is update :client/reload-key to a new random value.
This key gets queried for in the root component and as long as this key gets
passed into components (as a computed prop preferably) om-next will then force
update all those components.</p></li>
</ol>

      </div>
      <div class="dark-box">
      </div>
    </div>
  </body>
</html>
